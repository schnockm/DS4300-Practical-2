{
  "question": "When are linked lists faster than contiguously-allocated lists?",
  "llm_response": "From the provided context, it appears that linked lists and contiguously-allocated lists (arrays) are different data structures. The discussion about linked lists is in the context of binary search trees (BST), but there is no mention of arrays being used as contiguous lists.\n\nIn terms of time complexity, the best case scenario for linear search on a list or array is O(1), while the worst case is O(n). Binary search on a sorted array provides a logarithmic time complexity (O(log n)) which is generally faster than linear search when dealing with large datasets.\n\nHowever, linked lists are more advantageous in scenarios where insertions and deletions are frequent because updating an element in an array requires shifting all subsequent elements, whereas in a linked list, only the next pointers need to be updated. In contrast, searching in a linked list is slower than in an array since you need to follow pointers sequentially instead of accessing elements directly by index.\n\nSo, linked lists can potentially be faster when dealing with frequent insertions and deletions, but for searching large datasets, contiguously-allocated lists or arrays are generally preferred. To answer the question more precisely, it would require additional context on specific use cases and performance requirements related to the dataset size, frequency of insertions/deletions, and search operations.",
  "context": [
    "want upper bound ey n n cid21 2 n 1 0 1 ey 2emaxfy y g n icid01 ncid0i n x i1 emaxfy y g cid20 ey y icid01 ncid0i icid01 ncid0i cid20 ey ey icid01 ncid0i collecting terms ncid01 4 ey cid20 ey n n x i1 24 analysis 1 n3 claim n cid21 1 ey cid20 n 4cid16 3 cid17 prove induction n 0 base case ey 2 1 1 induction step ncid01 4 ey cid20 ey n n x",
    "github unless directed submit pdfs unless instructed submitting pdf sure associate questions gradescope correct page pdf failure result grade 0 assignment regrade requests submitted 48 hours grades released gradescope exceptions 8 midterm monday march 17 mark calendars 9 final grade breakdown homeworks 5 30 practicals 2 20 midterm 20 semester project 30 10 reference materials primary resources",
    "13 nil running time search 9 2 maximum minimum cid12nd minimum identify leftmost node farthest node reach following left branches cid12nd maximum identify rightmost node farthest node reach following right branches bst minimum x nil 1 x return tree 2 y x nil 3 lefty 6 y lefty 4 return keyy bst maximum x nil 1 x return tree 2 y x nil 3",
    "ncid01 4 ey cid20 ey n n x i1 using fact ncid01 3 n 3 x cid16 3 cid17 cid16 4 cid17 i0 4 1 n 3 ey cid20 cid1 cid1 n cid16 cid17 n 4 4 1 n 3 ey cid20 cid1 n cid16 cid17 4 3 25 jensens inequality function f convex x y x y cid21 0 cid20 cid21 cid20 1 fcid21x 1 cid0 cid21y cid20 cid21fx 1 cid0 cid21fy jensens inequality states random variables x convex",
    "typically concerned eventual consistency meaning distributed environment guarantee nodes eventually converge value 15 kv ds use cases edaexperimentation results store store intermediate results data preprocessing eda store experiment testing ab results wo prod db feature store store frequently accessed feature low latency retrieval model training prediction model monitoring store key metrics performance model example real time inferencing 16 kv swe use cases storing session information current session",
    "complex lends simple crud ops api creation 13 key value stores key value key value stores designed speed usually deployed memory db retrieving value given key typically o1 op bc hash tables similar data structs used hood concept complex queries joins slow things 14 key value stores key value key value stores designed scalability horizontal scaling simple add nodes typically concerned eventual consistency meaning distributed",
    "assignments httpsmarkfontenotnetteachingds430025s ds4300 assignment submissions grades gradescope q platform campuswire quick dms announcements slack 4 whats class end class understand efficiency related concepts including limitations rdbmss understand data replication distribution effects typical db usage scenarios understand use cases data models various nosql database systems including storing retrieving data data models include document based key value stores graph based access implement data engineering big data related aws services 5 course",
    "worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog n time 2 complexity 9 database searching assume data stored disk column ids value searching specific id fast want search specific specialval option linear scan column",
    "left right left right c g m p r z target mid left right 2 arrmid target mid return mid target arrmid reset right mid 1 left right elif arrmid target left mid 1 c g m p r z target mid right mid 1 return 1 8 time complexity linear search best case target element 1 comparison worst case target array n comparisons worst case linear search time",
    "random inserted tree keys inserted keys greater x right subtree x keys smaller x left subtree height tree constructed plus larger height left subtree height right subtree 23 random variables n number keys x height tree n keys n x y 2 n n want upper bound ey n n cid21"
  ],
  "config": {
    "chunk_size": 100,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0135,
    "llm_response_time_sec": 15.1622,
    "memory_before_MB": 49.73,
    "memory_after_MB": 51.68
  }
}
{
  "question": "What is the difference between a list where memory is contiguously allocated and a list where linked structures are used?\n",
  "llm_response": "In a list where memory is contiguously allocated, also known as an array or vector, all elements are stored continuously in memory. This type of data structure allows for fast access to any element at a specific index because the address of each element can be easily calculated based on its position within the list. However, inserting or deleting elements in the middle of the list requires shifting the remaining elements, which can be time-consuming if the list is large.\n\n   On the other hand, in a linked list, each element consists of data and a reference (or pointer) to the next element. This means that memory allocation can be more dynamic as only the required amount of memory needs to be allocated for each element at runtime. Insertion or deletion of elements in the middle is easier because it only involves updating the pointers instead of shifting all remaining elements, but accessing a specific element by its index may take longer due to needing to follow pointers sequentially.\n\n   The lecture notes mention Redis, which uses both types of lists (contiguously allocated and linked structures) in different contexts. Specifically, Redis lists are implemented as linked lists, while Redis arrays (implemented using the \"list\" command) may use either a contiguous allocation or a linked structure depending on the length of the list and other factors.",
  "context": [
    "ds 4300 redis python mark fontenot phd northeastern university redis py redis py standard client python maintained redis company github repo redisredis py 4300 conda environment pip install redis 2 connecting server import redis redis client redisredishostlocalhost port6379 db2 decode responsestrue docker deployment host localhost 127001 port port mapping given created container probably default 6379 db database 0 15 want connect decode responses data comes server bytes setting true",
    "fast 100000 set ops second rich collection commands does handle complex data secondary indexes supports lookup key 19 redis data types keys usually strings binary sequence values strings lists linked lists sets unique unsorted string elements sorted sets hashes string string geospatial data 20 setting redis docker docker desktop search redis pullrun latest image optional settings add 6379 ports expose port connect",
    "data comes server bytes setting true converter decodes strings 3 redis command list list use filter command particular data structure youre targeting list hash set redispy documentation slides meant exhaustive list commands highlights check documentation complete list 4 string commands r represents redis client object rsetclickcountabc 0 val rgetclickcountabc rincrclickcountabc ret val rgetclickcountabc printfclick count ret val 5 string commands 2 r represents redis client object redis clientmsetkey1",
    "rpipeline chain pipeline commands 3 result pipegetseat0getseat3getseat4execute printget 3 result 0 3 4 12 redis context 13 redis ml simplified example source httpswwwfeatureformcompostfeature stores explained common architectures 14 redis dsml source httpsmadewithmlcomcoursesmlopsfeature store 15",
    "commands 2 r represents redis client object redis clientmsetkey1 val1 key2 val2 key3 val3 printredis clientmgetkey1 key2 key3 returns list val1 val2 val3 6 string commands 3 set mset setex msetnx setnx mget getex getdel incr decr incrby decrby strlen append 7 list commands 1 create list key names values mark sam nick redis clientrpushnames mark sam nick prints mark sam nick printredis clientlrangenames 0 1 8 list commands 2 lpush lpop lset lrem rpush rpop lrange llen lpos commands include moving elements lists popping multiple",
    "commands set pathtoresource 0 set user1 john doe pathtoresource exists user1 del user1 keys user select 5 select different database 25 basic commands set somevalue 0 incr somevalue increment 1 incrby somevalue 10 increment 10 decr somevalue decrement 1 decrby somevalue 5 decrement 5 incr parses value int increments adds value setnx key value sets value key key does exist 26 hash type value kv entry collection field value pairs use",
    "commands include moving elements lists popping multiple lists time 9 hash commands 1 redis clienthsetuser session123 mappingfirst sam uelle company redis age 30 prints sam surname uelle company redis age 30 printredis clienthgetalluser session123 10 hash commands 2 hset hget hgetall hkeys hdel hexists hlen hstrlen 11 redis pipelines helps avoid multiple related calls server network overhead r redisredisdecode responsestrue pipe rpipeline range5 pipesetfseati fi set 5 result pipeexecute printset 5 result true true true true true pipe rpipeline chain pipeline commands 3 result pipegetseat0getseat3getseat4execute printget 3 result 0 3",
    "rownumber sorted specialval searching specialval slow linear scan required b inserting table theoretically quick add list 12 fast insert fast search binary search tree binary tree node left subtree parent node right subtree greater parent image httpscoursesgraingerillinoiseducs225sp2019notesbst 13 board 14",
    "6 7 8 9 11 12 15 19 20 preorder traversal gives 7 4 2 3 6 5 12 9 8 11 19 15 20 postorder traversal gives 3 2 5 6 4 8 11 9 15 20 19 12 7 inorder travel bst cid12nds keys nondecreasing order 6 operations bst 1 searching key assume key subtree key searched given input advantage bst property suppose node node",
    "kv entry collection field value pairs use cases used represent basic objectsstructures number fieldvalue pairs hash 232 1 practical limit available resources memory session information management userevent tracking include ttl active session tracking sessions hash key 27 hash commands hset bike1 model demios brand ergonom price 1971 hget bike1 model hget bike1 price hgetall bike1 hmget bike1 model price weight returned hincrby bike1 price 100 28 list type value kv pair linked lists string"
  ],
  "config": {
    "chunk_size": 100,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0159,
    "llm_response_time_sec": 15.6102,
    "memory_before_MB": 40.38,
    "memory_after_MB": 42.14
  }
}
{
  "question": "When was Redis originally released?",
  "llm_response": "I cannot find the specific release date of Redis in the given context. However, Redis (Remoted Database in Memory) is an open-source, in-memory data structure store that was created by Salvatore Sanfilippo in 2009.",
  "context": [
    "rpipeline chain pipeline commands 3 result pipegetseat0getseat3getseat4execute printget 3 result 0 3 4 12 redis context 13 redis ml simplified example source httpswwwfeatureformcompostfeature stores explained common architectures 14 redis dsml source httpsmadewithmlcomcoursesmlopsfeature store 15",
    "github unless directed submit pdfs unless instructed submitting pdf sure associate questions gradescope correct page pdf failure result grade 0 assignment regrade requests submitted 48 hours grades released gradescope exceptions 8 midterm monday march 17 mark calendars 9 final grade breakdown homeworks 5 30 practicals 2 20 midterm 20 semester project 30 10 reference materials primary resources",
    "read consistency monotonic read anomalies occur user reads values order multiple followers monotonic read consistency ensures user makes multiple reads read older data previously reading newer data 23 consistent prefix reads reading data order occur different partitions far future ms b replicate data different rates global write consistency consistent prefix read 10 seconds usually mr b guarantee ensures sequence writes happens certain order",
    "assignments httpsmarkfontenotnetteachingds430025s ds4300 assignment submissions grades gradescope q platform campuswire quick dms announcements slack 4 whats class end class understand efficiency related concepts including limitations rdbmss understand data replication distribution effects typical db usage scenarios understand use cases data models various nosql database systems including storing retrieving data data models include document based key value stores graph based access implement data engineering big data related aws services 5 course",
    "sequence writes happens certain order reading writes appear order 24 25",
    "database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 6 cap theorem review consistency availability responds latest data request gets response able deal network partitions consistency partition tolerance responds data distrib latest data request dropped availability partition tolerance sends responds based distributed store",
    "reads phantom reads transaction t running 1 transaction t adds 2 deletes rows set t using 1 figure httpswwwmybluelinuxcomrelational databases explained 9 example transaction transfer delimiter create procedure transfer sender id int receiver id int decimal102 begin declare rollback message varchar255 default transaction rolled insufficient funds declare commit message varchar255 default transaction committed successfully start transaction start transaction attempt debit money account 1 update accounts set balance balance account id sender id attempt credit money account 2 update accounts set",
    "attempt credit money account 2 update accounts set balance balance account id receiver id continued slide 10 example transaction transfer continued previous slide check sufficient funds account 1 simulate condition insufficient funds select balance accounts account id sender id 0 roll transaction insufficient funds rollback signal sqlstate 45000 45000 unhandled user defined error set message text rollback message log transactions sufficient funds insert transactions account id transaction type values sender id",
    "writing 1 2 result dirty read non repeatable read phantom reads 6 isolation dirty read dirty read transaction t able 1 read row modified transaction t 2 executed commit figure httpswwwmybluelinuxcomrelational databases explained 7 isolation non repeatable read non repeatable read queries single transaction t execute 1 select different values transaction t 2 changed data committed figure httpswwwmybluelinuxcomrelational databases explained 8 isolation phantom reads phantom reads transaction t running",
    "transaction fundamentals definition sequence crud operations performed single logical unit outcomes fully succeeds commit entirely fails rollback benefits data integrity error recovery concurrency control reliable storage acid properties atomicity transaction indivisible unit fully executed consistency database moves consistent state isolation concurrent transactions dont interfere potential issues dirty reads non repeatable reads phantom reads durability committed changes persist failures isolation issues 1 dirty read transaction reads uncommitted data"
  ],
  "config": {
    "chunk_size": 100,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0078,
    "llm_response_time_sec": 5.5651,
    "memory_before_MB": 38.93,
    "memory_after_MB": 40.68
  }
}
{
  "question": "Succinctly describe the four components of ACID compliant transactions.",
  "llm_response": "1. Atomicity ensures that each transaction is processed as a single, indivisible operation, either completing entirely or not at all.\n2. Consistency guarantees that after a transaction, the database will be in a valid state that adheres to established rules and constraints.\n3. Isolation ensures that concurrent execution of transactions does not interfere with each other, creating an illusion that they execute sequentially.\n4. Durability ensures that once a transaction is committed, it remains durable even in the event of system failures or crashes.",
  "context": [
    "group membership supports set operations 35 set commands sadd ds4300 mark sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam sismember ds4300 mark sismember ds4300 nick scard ds4300 36 sadd ds4300 mark set commands sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam scard ds4300 sinter ds4300 cs3200 sdiff ds4300 cs3200 srem ds4300 mark srandmember ds4300 37 38",
    "collection values attribues single entity instance row table collection set records entity type table trvially stored sequuential order like list search key value attribute entity type 1 attribute nx bytes memory record takes x bytes memory n records need contiguously allocated list nx byte allocated single chunk memory linked list record needs x bytes additional space 1 2 memory",
    "login httpsneo4jcomdocsbrowser manualcurrentvisual tour 10 inserting data creating nodes create user alice birthplace paris create user bob birthplace london create user carol birthplace london create user dave birthplace london create user eve birthplace rome 11 adding edge variable names create user alice birthplace paris create user bob birthplace london match aliceuser namealice match bobuser bob create alice knows 2022 12 01 bob note relationships directed neo4j 12 matching users born london match usruser birthplace london return usrname usrbirthplace 13 download dataset import folder clone",
    "ds 4300 neo4j mark fontenot phd northeastern university material referenced graph algorithms practical examples apache spark neo4j needham hodler oreilly press 2019 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 2 neo4j query language plugins cypher neo4js graph query language created 2011 goal sql equivalent language",
    "commands include moving elements lists popping multiple lists time 9 hash commands 1 redis clienthsetuser session123 mappingfirst sam uelle company redis age 30 prints sam surname uelle company redis age 30 printredis clienthgetalluser session123 10 hash commands 2 hset hget hgetall hkeys hdel hexists hlen hstrlen 11 redis pipelines helps avoid multiple related calls server network overhead r redisredisdecode responsestrue pipe rpipeline range5 pipesetfseati fi set 5 result pipeexecute printset 5 result true true true true true pipe rpipeline chain pipeline commands 3 result pipegetseat0getseat3getseat4execute printget 3 result 0 3",
    "partitioning nodes graph tendency strengthen break apart 18 centrality 19 famous graph algorithms dijkstras algorithm single source shortest path algo positively weighted graphs algorithm similar dijkstras added feature using heuristic guide traversal pagerank measures importance node graph based number incoming relationships importance nodes incoming relationships 20 neo4j graph database supports transactional analytical processing graph based data relatively new class",
    "kv entry collection field value pairs use cases used represent basic objectsstructures number fieldvalue pairs hash 232 1 practical limit available resources memory session information management userevent tracking include ttl active session tracking sessions hash key 27 hash commands hset bike1 model demios brand ergonom price 1971 hget bike1 model hget bike1 price hgetall bike1 hmget bike1 model price weight returned hincrby bike1 price 100 28 list type value kv pair linked lists string",
    "complex lends simple crud ops api creation 13 key value stores key value key value stores designed speed usually deployed memory db retrieving value given key typically o1 op bc hash tables similar data structs used hood concept complex queries joins slow things 14 key value stores key value key value stores designed scalability horizontal scaling simple add nodes typically concerned eventual consistency meaning distributed",
    "caused modified 3 optimistic concurrency low conflict systems backups analytical dbs read heavy systems conflicts arise handled rolling running transaction notices conflict optimistic concurrency works allows higher concurrency high conflict systems rolling rerunning transactions encounter conflict efficient locking scheme pessimistic model preferable 4 nosql nosql used 1998 carlo strozzi relational database did use sql",
    "data comes server bytes setting true converter decodes strings 3 redis command list list use filter command particular data structure youre targeting list hash set redispy documentation slides meant exhaustive list commands highlights check documentation complete list 4 string commands r represents redis client object rsetclickcountabc 0 val rgetclickcountabc rincrclickcountabc ret val rgetclickcountabc printfclick count ret val 5 string commands 2 r represents redis client object redis clientmsetkey1"
  ],
  "config": {
    "chunk_size": 100,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0432,
    "llm_response_time_sec": 9.0728,
    "memory_before_MB": 14.11,
    "memory_after_MB": 16.1
  }
}
{
  "question": "What is disk-based indexing and why is it important for database systems?\n    ",
  "llm_response": "In the provided context, there's no explicit definition of \"disk-based indexing.\" However, based on the general concept of databases, we can infer that disk-based indexing refers to the process of creating data structures (indexes) on a hard disk drive (HDD) or solid-state drive (SSD), aiming to improve the efficiency of data retrieval in database systems.\n\nIndexing is essential for database systems due to the following reasons:\n\n1. Speed up search operations: Indexes allow for faster data retrieval, especially when searching large datasets, as they enable the database to skip over unnecessary data and quickly locate the required information. This is particularly important in scenarios where real-time responses are crucial.\n\n2. Reduce I/O overhead: By reducing the amount of data that needs to be scanned during a query, indexes help minimize the number of disk reads (I/O operations), which can significantly improve the performance and efficiency of database systems, especially when dealing with large datasets.\n\n3. Optimize query performance: Indexing helps optimize the performance of complex queries by allowing the database to quickly narrow down the search space to a smaller subset of data, making it easier and faster to retrieve the required information. This can be particularly beneficial in scenarios where queries involve conditions or filters that can leverage indexes for efficient data retrieval.\n\n4. Improve scalability: As databases grow larger, managing and querying such datasets can become increasingly challenging. Indexing helps improve scalability by enabling databases to handle larger volumes of data more efficiently, making it easier to perform complex operations on a growing dataset without significantly impacting performance or response times.",
  "context": [
    "commands set pathtoresource 0 set user1 john doe pathtoresource exists user1 del user1 keys user select 5 select different database 25 basic commands set somevalue 0 incr somevalue increment 1 incrby somevalue 10 increment 10 decr somevalue decrement 1 decrby somevalue 5 decrement 5 incr parses value int increments adds value setnx key value sets value key key does exist 26 hash type value kv entry collection field value pairs use",
    "sequence writes happens certain order reading writes appear order 24 25",
    "node points element list points nilnull o1 insert new value insert new value end 30 list commands queue queue like ops lpush bikesrepairs bike1 lpush bikesrepairs bike2 rpop bikesrepairs rpop bilesrepairs 31 list commands stack stack like ops lpush bikesrepairs bike1 lpush bikesrepairs bike2 lpop bikesrepairs lpop bilesrepairs 32 list commands lpush mylist lpush mylist list ops lpush mylist llen mylist lrange key start stop lrange mylist 0 3 lrange mylist 0 0 lrange mylist 2 1",
    "commands include moving elements lists popping multiple lists time 9 hash commands 1 redis clienthsetuser session123 mappingfirst sam uelle company redis age 30 prints sam surname uelle company redis age 30 printredis clienthgetalluser session123 10 hash commands 2 hset hget hgetall hkeys hdel hexists hlen hstrlen 11 redis pipelines helps avoid multiple related calls server network overhead r redisredisdecode responsestrue pipe rpipeline range5 pipesetfseati fi set 5 result pipeexecute printset 5 result true true true true true pipe rpipeline chain pipeline commands 3 result pipegetseat0getseat3getseat4execute printget 3 result 0 3",
    "rownumber sorted specialval searching specialval slow linear scan required b inserting table theoretically quick add list 12 fast insert fast search binary search tree binary tree node left subtree parent node right subtree greater parent image httpscoursesgraingerillinoiseducs225sp2019notesbst 13 board 14",
    "rpipeline chain pipeline commands 3 result pipegetseat0getseat3getseat4execute printget 3 result 0 3 4 12 redis context 13 redis ml simplified example source httpswwwfeatureformcompostfeature stores explained common architectures 14 redis dsml source httpsmadewithmlcomcoursesmlopsfeature store 15",
    "1 command used start stop scale number services time provides consistent method producing identical environment works machine interaction command line 5 docker composeyaml services secrets neo4j container neo4j docker compose file use env image neo4jlatest ports files 74747474 76877687 environment neo4j authneo4jneo4j password neo4j apoc export file enabledtrue neo4j apoc import file enabledtrue neo4j apoc import file use neo4j configtrue neo4j pluginsapoc graph data science volumes neo4j dbdatadata neo4j dblogslogs neo4j dbimportvarlibneo4jimport neo4j dbpluginsplugins 6 env files env files stores collection environment variables",
    "make space linked lists faster inserting list slower random access insert 2nd record 6 observations arrays fast random access slow random insertions linked lists slow random access fast random insertions 7 binary search input array values sorted order target value output location index target located value indicating target def binary searcharr target left right 0 lenarr 1 left right left right c g m p",
    "group membership supports set operations 35 set commands sadd ds4300 mark sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam sismember ds4300 mark sismember ds4300 nick scard ds4300 36 sadd ds4300 mark set commands sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam scard ds4300 sinter ds4300 cs3200 sdiff ds4300 cs3200 srem ds4300 mark srandmember ds4300 37 38",
    "env files stores collection environment variables good way environment variables different platforms separate envlocal env file envdev envprod neo4j passwordabc123 7 docker compose commands test docker cli properly installed run docker version major docker commands docker compose docker compose d docker compose docker compose start docker compose stop docker compose build docker compose build cache 8 localhost7474 9 neo4j browser localhost7474 login httpsneo4jcomdocsbrowser manualcurrentvisual tour 10 inserting data creating nodes create user"
  ],
  "config": {
    "chunk_size": 100,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0084,
    "llm_response_time_sec": 18.0856,
    "memory_before_MB": 12.94,
    "memory_after_MB": 14.7
  }
}
{
  "question": "When are linked lists faster than contiguously-allocated lists?",
  "llm_response": "Linked lists can be faster than contiguously-allocated lists in the following scenarios:\n\n1. Inserting at the end of a list: Since each new record in a linked list only requires a new memory address (O(1) space), adding a new element to the end of a linked list is faster than adding a new element to a contiguously-allocated list, where you need to allocate additional space and possibly shift existing elements (O(n)).\n\n2. Random insertions: While inserting into the middle or random positions of a list, the time complexity for a linked list remains O(1) for each insertion operation, as opposed to O(n) in a contiguously-allocated list because you would need to shift existing elements to make space for the new one.\n\n3. Large scale databases: For very large datasets (e.g., millions of records), linked lists can be more efficient due to their dynamic memory management, as they don't require pre-allocating contiguous blocks of memory in advance, which can lead to significant waste when the actual data size is smaller than initially allocated. However, this advantage comes at the cost of slower random access operations compared to contiguously-allocated lists.\n\n4. Real-time systems and online applications: Linked lists are often used in real-time systems and online applications due to their efficient insertion capabilities, as new data can be added rapidly without worrying about memory allocation issues or shifting existing data.",
  "context": [
    "sequence writes happens certain order reading writes appear order 24 25",
    "chapter 12 binary search trees binary search tree binary tree special property called bst property given follows nodes x y y belongs left subtree x key y key x y belongs right subtree x key y greater key x assume keys bst pairwise distinct node following attributes cid15 p left right pointers parent left child right child respectively cid15 key key stored node 1 example 7 4 12 2 6 9 19 3 5 8 11 15 20 2 traversal nodes bst traversal mean visiting nodes graph traversal strategies specicid12ed ordering objects visit current node left subtree right subtree assume left subtree comes right subtree strategies 1 inorder ordering left subtree current node right subtree 2 preorder ordering current node left subtree right subtree 3 postorder ordering left subtree right subtree current node 3 inorder traversal pseudocode recursive algorithm takes input pointer tree executed inorder traversal tree doing traversal prints key node visited inorder walk x nil 1 x return inorder walk 2 leftx 3 print keyx inorder walk 4 rightx write similar pseudocode preorder postorder 4 2 1 3 1 3 2 3 1 2 inorder preorder postorder 7 4 12 2 6 9 19 3 5 8 11 15 20 outcome inorder traversal bst postorder traversal preorder traversal 5 inorder traversal gives 2 3 4 5 6 7 8 9 11 12 15 19 20 preorder traversal gives 7 4 2 3 6 5 12 9 8 11 19 15 20 postorder traversal gives 3 2 5 6 4 8 11 9 15 20 19 12 7 inorder travel bst cid12nds keys nondecreasing order 6 operations bst 1 searching key assume key subtree key searched given input advantage bst property suppose node node key searched search key current node strictly smaller key searched strictly greater key searched",
    "ds 4300 large scale information storage retrieval foundations mark fontenot phd northeastern university searching searching common operation performed database sql select statement arguably versatile complex baseline efficiency linear search start beginning list proceed element element youre looking element havent 2 searching record collection values attributes single entity instance row table collection set records entity type table trivially stored sequential order like list search key value attribute entity type 1 attribute 3 lists records record takes x bytes memory n records need nx bytes memory contiguously allocated list nx bytes allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses 4 contiguous vs linked 6 records contiguously allocated array extra storage memory address 6 records linked memory addresses linked list 5 pros cons arrays faster random access slow inserting end records insert 2nd record records 5 records moved make space linked lists faster inserting list slower random access insert 2nd record 6 observations arrays fast random access slow random insertions linked lists slow random access fast random insertions 7 binary search input array values sorted order target value output location index target located value indicating target def binary searcharr target left right 0 lenarr 1 left right left right c g m p r z target mid left right 2 arrmid target mid return mid target arrmid reset right mid 1 left right elif arrmid target left mid 1 c g m p r z target mid right mid 1 return 1 8 time complexity linear search best case target element 1 comparison worst case target array n comparisons worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog",
    "worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog n time 2 complexity 9 database searching assume data stored disk column ids value searching specific id fast want search specific specialval option linear scan column store data disk sorted id specialval time data duplicated space inefficient 10 database searching assume data stored disk column ids value searching specific id fast want search specific need external data structure specialval support faster searching option linear scan column specialval linear scan store data disk sorted id specialval time data duplicated space inefficient 11 arsenal 1 array tuples specialval rownumber sorted specialval use binary search quickly locate particular specialval corresponding row table b insert table like inserting sorted array slow 2 linked list tuples specialval rownumber sorted specialval searching specialval slow linear scan required b inserting table theoretically quick add list 12 fast insert fast search binary search tree binary tree node left subtree parent node right subtree greater parent image httpscoursesgraingerillinoiseducs225sp2019notesbst 13 board 14",
    "ds 4300 large scale information storage retrieval mark fontenot phd northeastern university hi mark fontenot phd office 353 meserve hall office hours m th 130 300 pm times dont work just dm slack set alternate time usually available slack just dm mfontenotnortheasternedu 2 teaching assistants iker acosta venegas dallon archibald nathan cheung aryan jain sevinch noori abhishek kumar eddy liu junxiang lin 3 course materials notes assignments httpsmarkfontenotnetteachingds430025s ds4300 assignment submissions grades gradescope q platform campuswire quick dms announcements slack 4 whats class end class understand efficiency related concepts including limitations rdbmss understand data replication distribution effects typical db usage scenarios understand use cases data models various nosql database systems including storing retrieving data data models include document based key value stores graph based access implement data engineering big data related aws services 5 course deliverables evaluation 6 assignments homeworks practicals usually tuesday nights 1159 unless stated 3 bonus submitting 48 hours early 3 submitting 48 hours early late submissions accepted life happens gets 1 free questions asked 48 hour extension dm dr fontenot slack original deadline requesting use extension 7 assignments submissions gradescope andor github unless directed submit pdfs unless instructed submitting pdf sure associate questions gradescope correct page pdf failure result grade 0 assignment regrade requests submitted 48 hours grades released gradescope exceptions 8 midterm monday march 17 mark calendars 9 final grade breakdown homeworks 5 30 practicals 2 20 midterm 20 semester project 30 10 reference materials primary resources books playlist add additional materials playlist webpage semester progresses oreilly playlist 11 tentative list topics thinking data storage retrieval data structures level far relational model nosql databases document databases mongo graph databases neo4j keyvalue databases maybe vector databases data distribution replication distributed sql dbs apache sparksparksql big data tools services aws 12 tools need install laptop docker desktop anaconda miniconda python youre welcome use distro youre responsible fixing doesnt work dependency conflicts database access tool like datagrip",
    "sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 7 acid alternative distrib systems base basically available guarantees availability data cap response failureunreliable data inconsistent changing state appears work time 8 acid alternative distrib systems base soft state state change time wo input changes result eventual consistency data stores dont write consistent replicas dont mutually consistent 9 acid alternative distrib systems base eventual consistency eventually consistent writes eventually stop nodesreplicas updated 10 categories nosql dbs review 11 key value databases 12 key value stores key value key value stores designed simplicity data model extremely simple comparatively tables rdbms complex lends simple crud ops api creation 13 key value stores key value key value stores designed speed usually deployed memory db retrieving value given key typically o1 op bc hash tables similar data structs used hood concept complex queries joins slow things 14 key value stores key value key value stores designed scalability horizontal scaling simple add nodes typically concerned eventual consistency meaning distributed environment guarantee nodes eventually converge value 15 kv ds use cases edaexperimentation results store store intermediate results data preprocessing eda store experiment testing ab results wo prod db feature store store frequently accessed feature low latency retrieval model training prediction model monitoring store key metrics performance model example real time inferencing 16 kv swe use cases storing session information current session stored single post retrieved single fast user profiles preferences user info obtained single operation language tz product ui preferences shopping cart data cart data tied user needs available browsers machines sessions caching layer disk based database 17 redis db redis remote directory server open source memory database called data structure store primarily kv store used models graph spatial text search vector time series db enginescom ranking kv stores 18 redis considered memory database supports durability",
    "range queries efficient bst properties left subtree values root right subtree values search time complexity olog n balanced unbalanced avl trees self balancing bst ensures olog n search time rotations used rebalancing ll rotation single right rotation rr rotation single left rotation lr rotation left right rotation rl rotation right left rotation sql vs sql sql structured query langage relational easy querying relationships data multiple datas acid compliant atomicity consistency isolation durability good storing querying unstructured data format unknown difficult scale horizontally nosql document keyvalue graph wide column stores flexible simpler set shard data different data stores allowing distributed databases making horizontal scaling easier large data stored designed distributed purposes optimistic concurrency assumes conflicts unlikely occur add updated timestamp version number columns table modified independently transactions relational databases vs nosql acid vs base acid ensures strong consistency atomicity transactions consistency data remains valid isolation transactions interfere durability committed stays committed base prioritizes availability consistency basically available soft state eventually consistent sql vs nosql feature sql relational nosql non relational schema fixed structured flexible dynamic scalability vertical scale horizontal scale consistency strong acid compliance eventual consistency examples mysql postgresql mongodb cassandra neo4j nosql cap theorem consistency nodes data simultaneously availability request gets response stale partition tolerance functions despite network failures nosql categories type example use case key value redis caching real time stores dynamodb analytics document mongodb json like flexible data stores couchdb models column stores apache time series analytics cassandra graph neo4j relationship heavy data databases graph data models neo4j graph theory basics nodes entities users products edges relationships nodes traversal algorithms bfs dfs dijkstras shortest path neo4j cypher neo4j acid compliant graph database cypher query examples match friend b return b data replication distributed systems improves fault tolerance node crashes serve data enables load balancing distribute requests multiple servers replication strategies master slave replication node handles writes replicate reads multi master replication multiple nodes accept writes requires conflict resolution eventual consistency updates propagate time used nosql systems like dynamodb",
    "21 cid3 y right child parent 22 cid3 set parents right child x 23 y 6 z 24 f keyz keyy 25 data y z g 27 return y 20 summary ecid14ciency analysis theorem binary search tree search minimum maximum height h successor predecessor insert delete run oh time 21 randomly built bst suppose insert n distinct keys initially tree assuming n permutations equally likely occur average height tree study question consider process constructing tree t inserting order randomly selected n distinct keys initially tree actually values keys matter matters position inserted key n keys 22 process construction view process follows key x keys selected uniformly random inserted tree keys inserted keys greater x right subtree x keys smaller x left subtree height tree constructed plus larger height left subtree height right subtree 23 random variables n number keys x height tree n keys n x y 2 n n want upper bound ey n n cid21 2 n 1 0 1 ey 2emaxfy y g n icid01 ncid0i n x i1 emaxfy y g cid20 ey y icid01 ncid0i icid01 ncid0i cid20 ey ey icid01 ncid0i collecting terms ncid01 4 ey cid20 ey n n x i1 24 analysis 1 n3 claim n cid21 1 ey cid20 n 4cid16 3 cid17 prove induction n 0 base case ey 2 1 1 induction step ncid01 4 ey cid20 ey n n x i1 using fact ncid01 3 n 3 x cid16 3 cid17 cid16 4 cid17 i0 4 1 n 3 ey cid20 cid1 cid1 n cid16 cid17 n 4 4 1 n 3 ey cid20 cid1 n cid16 cid17 4 3 25 jensens inequality function f convex x y x y cid21 0 cid20 cid21 cid20 1 fcid21x 1 cid0 cid21y cid20 cid21fx 1 cid0 cid21fy jensens inequality states random variables x convex function f fex cid20 efx x let x x fx 2 n efx ey n 1 n 3 ex 2 n cid20 cid16 cid17 4 3 3 right hand",
    "general trade offs exist consistency availability performance indexing strategies significantly impact query performance nosql databases great unstructured data sacrifice strong consistency graph databases optimized relationships large scale storage retrieval foundations foundations large scale storage retrieval introduction information storage information retrieval ir process storing organizing retrieving data efficiently ir systems range search engines google databases storing medical records key challenges scalability handling petabytes data efficiency fast retrieval times google milliseconds consistency availability ensuring fault tolerance reliability searching strategies linear search simple inefficient time complexity binary search works sorted data olog n complexity indexing key making search efficient uses external data structures like b trees hash indexes indexing techniques hash indexing best unique lookups o1 average case b trees b trees used databases optimized disk access inverted index used search engines maps words documents record collection values attribues single entity instance row table collection set records entity type table trvially stored sequuential order like list search key value attribute entity type 1 attribute nx bytes memory record takes x bytes memory n records need contiguously allocated list nx byte allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses arrays faster random access inserting end slow linked lists faster inserting list random access slow linear search best case 1 worst case binary search best case 1 worst case log2n read code explain binary search isdoes binary search tree binary tree node left subtree parent node right parent avl tree approx balanced binary search tree maintains balance faster avl property hlst hrst 1 self balancing inserting imbalance ll lr rl rr trees b trees indexing b trees used database indexing filesystems ntfs postgresql indexes keeps tree height small reducing disk reads b trees vs b trees b trees store keys values internal leaf nodes b trees store values leaf nodes making range queries efficient bst properties left subtree values root right subtree values search time complexity olog n balanced unbalanced avl trees self balancing bst ensures olog n search time rotations used rebalancing ll rotation single right rotation rr rotation single left rotation",
    "random variables x convex function f fex cid20 efx x let x x fx 2 n efx ey n 1 n 3 ex 2 n cid20 cid16 cid17 4 3 3 right hand n 3 taking log sides ex olog n n average height randomly build bst olog n 26"
  ],
  "config": {
    "chunk_size": 500,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.018,
    "llm_response_time_sec": 20.8785,
    "memory_before_MB": 13.65,
    "memory_after_MB": 15.35
  }
}
{
  "question": "What is the difference between a list where memory is contiguously allocated and a list where linked structures are used?",
  "llm_response": "The main difference between a list where memory is contiguously allocated (also known as an array) and a list where linked structures are used (also known as a linked list) lies in how elements are stored and accessed within the data structure.\n\n1. Contiguous Allocation: In arrays, each element occupies a specific, consecutive memory location starting from a base address. This makes it easy to access any particular element by its index because its position is known. However, this also means that resizing an array can be inefficient as either more memory needs to be allocated or existing elements need to be shifted around.\n\n2. Linked Structures: In linked lists, each node contains a data field and a reference (or pointer) to the next node. This means nodes don't have to be stored contiguously in memory. This makes it easier to add new elements since you only need to allocate memory for the new node without disturbing existing ones. However, accessing a specific element using an index is less efficient because you have to traverse through the list from the head (the starting point) until you reach the desired position.\n\nIn terms of operations like insertion, deletion, and searching, linked lists are more dynamic and flexible but less efficient for random access compared to arrays. The choice between these two data structures depends on the specific use case and requirements such as performance, memory efficiency, and the nature of the data being stored.",
  "context": [
    "sequence writes happens certain order reading writes appear order 24 25",
    "chapter 12 binary search trees binary search tree binary tree special property called bst property given follows nodes x y y belongs left subtree x key y key x y belongs right subtree x key y greater key x assume keys bst pairwise distinct node following attributes cid15 p left right pointers parent left child right child respectively cid15 key key stored node 1 example 7 4 12 2 6 9 19 3 5 8 11 15 20 2 traversal nodes bst traversal mean visiting nodes graph traversal strategies specicid12ed ordering objects visit current node left subtree right subtree assume left subtree comes right subtree strategies 1 inorder ordering left subtree current node right subtree 2 preorder ordering current node left subtree right subtree 3 postorder ordering left subtree right subtree current node 3 inorder traversal pseudocode recursive algorithm takes input pointer tree executed inorder traversal tree doing traversal prints key node visited inorder walk x nil 1 x return inorder walk 2 leftx 3 print keyx inorder walk 4 rightx write similar pseudocode preorder postorder 4 2 1 3 1 3 2 3 1 2 inorder preorder postorder 7 4 12 2 6 9 19 3 5 8 11 15 20 outcome inorder traversal bst postorder traversal preorder traversal 5 inorder traversal gives 2 3 4 5 6 7 8 9 11 12 15 19 20 preorder traversal gives 7 4 2 3 6 5 12 9 8 11 19 15 20 postorder traversal gives 3 2 5 6 4 8 11 9 15 20 19 12 7 inorder travel bst cid12nds keys nondecreasing order 6 operations bst 1 searching key assume key subtree key searched given input advantage bst property suppose node node key searched search key current node strictly smaller key searched strictly greater key searched",
    "sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 7 acid alternative distrib systems base basically available guarantees availability data cap response failureunreliable data inconsistent changing state appears work time 8 acid alternative distrib systems base soft state state change time wo input changes result eventual consistency data stores dont write consistent replicas dont mutually consistent 9 acid alternative distrib systems base eventual consistency eventually consistent writes eventually stop nodesreplicas updated 10 categories nosql dbs review 11 key value databases 12 key value stores key value key value stores designed simplicity data model extremely simple comparatively tables rdbms complex lends simple crud ops api creation 13 key value stores key value key value stores designed speed usually deployed memory db retrieving value given key typically o1 op bc hash tables similar data structs used hood concept complex queries joins slow things 14 key value stores key value key value stores designed scalability horizontal scaling simple add nodes typically concerned eventual consistency meaning distributed environment guarantee nodes eventually converge value 15 kv ds use cases edaexperimentation results store store intermediate results data preprocessing eda store experiment testing ab results wo prod db feature store store frequently accessed feature low latency retrieval model training prediction model monitoring store key metrics performance model example real time inferencing 16 kv swe use cases storing session information current session stored single post retrieved single fast user profiles preferences user info obtained single operation language tz product ui preferences shopping cart data cart data tied user needs available browsers machines sessions caching layer disk based database 17 redis db redis remote directory server open source memory database called data structure store primarily kv store used models graph spatial text search vector time series db enginescom ranking kv stores 18 redis considered memory database supports durability",
    "partitioning nodes graph tendency strengthen break apart 18 centrality 19 famous graph algorithms dijkstras algorithm single source shortest path algo positively weighted graphs algorithm similar dijkstras added feature using heuristic guide traversal pagerank measures importance node graph based number incoming relationships importance nodes incoming relationships 20 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 21 22",
    "assumes conflicts occur uses locks optimistic concurrency locks assumes conflicts rare uses timestamps version numbers good read heavy systems efficient high conflict systems base alternative acid distributed systems basically available works time soft state state change input eventual consistency eventually reach consistency 8 key value databases design principles simplicity extremely simple data model compared rdbms speed memory o1 retrieval operations scalability easy horizontal scaling eventual consistency use cases data science experiment results storage feature storage model monitoring software engineering session information user profiles shopping carts caching 9 redis key value database open source memory database high performance 100000 set opssecond supports data durability snapshots append journals simple lookup key secondary indexes data types strings basic textbinary data lists linked lists queuesstacks sets unique unordered string collections hashes field value collections sorted sets sets scores ordering specialized types geospatial data json common operations basic crud set exists del atomic counters incr incrby decr decrby list operations lpush rpush lpop rpop llen lrange set operations sadd scard sismember sinter sdiff hash operations hset hget hgetall",
    "worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog n time 2 complexity 9 database searching assume data stored disk column ids value searching specific id fast want search specific specialval option linear scan column store data disk sorted id specialval time data duplicated space inefficient 10 database searching assume data stored disk column ids value searching specific id fast want search specific need external data structure specialval support faster searching option linear scan column specialval linear scan store data disk sorted id specialval time data duplicated space inefficient 11 arsenal 1 array tuples specialval rownumber sorted specialval use binary search quickly locate particular specialval corresponding row table b insert table like inserting sorted array slow 2 linked list tuples specialval rownumber sorted specialval searching specialval slow linear scan required b inserting table theoretically quick add list 12 fast insert fast search binary search tree binary tree node left subtree parent node right subtree greater parent image httpscoursesgraingerillinoiseducs225sp2019notesbst 13 board 14",
    "21 cid3 y right child parent 22 cid3 set parents right child x 23 y 6 z 24 f keyz keyy 25 data y z g 27 return y 20 summary ecid14ciency analysis theorem binary search tree search minimum maximum height h successor predecessor insert delete run oh time 21 randomly built bst suppose insert n distinct keys initially tree assuming n permutations equally likely occur average height tree study question consider process constructing tree t inserting order randomly selected n distinct keys initially tree actually values keys matter matters position inserted key n keys 22 process construction view process follows key x keys selected uniformly random inserted tree keys inserted keys greater x right subtree x keys smaller x left subtree height tree constructed plus larger height left subtree height right subtree 23 random variables n number keys x height tree n keys n x y 2 n n want upper bound ey n n cid21 2 n 1 0 1 ey 2emaxfy y g n icid01 ncid0i n x i1 emaxfy y g cid20 ey y icid01 ncid0i icid01 ncid0i cid20 ey ey icid01 ncid0i collecting terms ncid01 4 ey cid20 ey n n x i1 24 analysis 1 n3 claim n cid21 1 ey cid20 n 4cid16 3 cid17 prove induction n 0 base case ey 2 1 1 induction step ncid01 4 ey cid20 ey n n x i1 using fact ncid01 3 n 3 x cid16 3 cid17 cid16 4 cid17 i0 4 1 n 3 ey cid20 cid1 cid1 n cid16 cid17 n 4 4 1 n 3 ey cid20 cid1 n cid16 cid17 4 3 25 jensens inequality function f convex x y x y cid21 0 cid20 cid21 cid20 1 fcid21x 1 cid0 cid21y cid20 cid21fx 1 cid0 cid21fy jensens inequality states random variables x convex function f fex cid20 efx x let x x fx 2 n efx ey n 1 n 3 ex 2 n cid20 cid16 cid17 4 3 3 right hand",
    "ds 4300 nosql kv dbs mark fontenot phd northeastern university material used permission dr rachlin thanks distributed dbs acid pessimistic concurrency acid transactions focuses data safety considered pessimistic concurrency model assumes transaction protect transactions iow assumes wrong conflicts prevented locking resources transaction complete read write locks write lock analogy borrowing book library httpswwwfreecodecamporgnewshow databases guarantee isolation deeper dive 2 optimistic concurrency transactions obtain locks data read write optimistic assumes conflicts unlikely occur conflict ok add update timestamp version number columns table read changing check end transaction transaction caused modified 3 optimistic concurrency low conflict systems backups analytical dbs read heavy systems conflicts arise handled rolling running transaction notices conflict optimistic concurrency works allows higher concurrency high conflict systems rolling rerunning transactions encounter conflict efficient locking scheme pessimistic model preferable 4 nosql nosql used 1998 carlo strozzi relational database did use sql common modern meaning sql thought non relational dbs idea originally developed response processing unstructured web based data httpswwwdataversityneta brief history non relational databases 5 cap theorem review 2 3 following consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 6 cap theorem review consistency availability responds latest data request gets response able deal network partitions consistency partition tolerance responds data distrib latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 7 acid alternative distrib systems base basically available guarantees availability data cap response failureunreliable data",
    "attempt credit money account 2 update accounts set balance balance account id receiver id continued slide 10 example transaction transfer continued previous slide check sufficient funds account 1 simulate condition insufficient funds select balance accounts account id sender id 0 roll transaction insufficient funds rollback signal sqlstate 45000 45000 unhandled user defined error set message text rollback message log transactions sufficient funds insert transactions account id transaction type values sender id withdrawal insert transactions account id transaction type values receiver id deposit commit transaction commit select commit message result end end delimiter 11 acid properties durability transaction completed committed successfully changes permanent event failure committed transactions preserved info transactions kleppmann book chapter 7 12 relational databases solution problems schemas evolve time apps need strength acid compliance joins expensive lot data semi structured unstructured json xml horizontal scaling presents challenges apps need performant real time low latency systems 13 scalability conventional wisdom scale vertically bigger powerful systems demands high availability make necessary scale type distributed computing model scaling easier need really modify architecture practical financial limits modern systems make horizontal scaling problematic 14 distributed data scaling distributed collection independent computers appear users computer andrew tennenbaum characteristics distributed systems computers operate concurrently computers fail independently shared global clock 15 distributed storage 2 directions single main node 16 distributed data stores data stored 1 node typically replicated block data available n nodes distributed databases relational non relational mysql postgresql support replication sharding cockroachdb new player scene nosql systems support models remember network partitioning inevitable network failures failures overall needs partition tolerant running w network partition 17 cap theorem 18 cap theorem cap theorem states impossible distributed data store simultaneously provide following guarantees consistency read receives recent write error thrown availability request receives non error response guarantee response contains",
    "impossible distributed data store simultaneously provide following guarantees consistency read receives recent write error thrown availability request receives non error response guarantee response contains recent write partition tolerance continue operate despite arbitrary network issues 19 cap theorem database view consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 20 cap theorem database view consistency availability responds latest data request gets response able deal network issues consistency partition tolerance responds data distributed store latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 21 cap reality really saying limit number faults requests directed server insist serving request possibly consistent interpreted consistency availability tolerance failure 22 23"
  ],
  "config": {
    "chunk_size": 500,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0185,
    "llm_response_time_sec": 20.2175,
    "memory_before_MB": 13.68,
    "memory_after_MB": 15.71
  }
}
{
  "question": "When was Redis originally released?",
  "llm_response": "Redis (an in-memory data structure store) was first released by Salvatore Sanfilippo on December 24, 2009.",
  "context": [
    "sequence writes happens certain order reading writes appear order 24 25",
    "impossible distributed data store simultaneously provide following guarantees consistency read receives recent write error thrown availability request receives non error response guarantee response contains recent write partition tolerance continue operate despite arbitrary network issues 19 cap theorem database view consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 20 cap theorem database view consistency availability responds latest data request gets response able deal network issues consistency partition tolerance responds data distributed store latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 21 cap reality really saying limit number faults requests directed server insist serving request possibly consistent interpreted consistency availability tolerance failure 22 23",
    "ds 4300 nosql kv dbs mark fontenot phd northeastern university material used permission dr rachlin thanks distributed dbs acid pessimistic concurrency acid transactions focuses data safety considered pessimistic concurrency model assumes transaction protect transactions iow assumes wrong conflicts prevented locking resources transaction complete read write locks write lock analogy borrowing book library httpswwwfreecodecamporgnewshow databases guarantee isolation deeper dive 2 optimistic concurrency transactions obtain locks data read write optimistic assumes conflicts unlikely occur conflict ok add update timestamp version number columns table read changing check end transaction transaction caused modified 3 optimistic concurrency low conflict systems backups analytical dbs read heavy systems conflicts arise handled rolling running transaction notices conflict optimistic concurrency works allows higher concurrency high conflict systems rolling rerunning transactions encounter conflict efficient locking scheme pessimistic model preferable 4 nosql nosql used 1998 carlo strozzi relational database did use sql common modern meaning sql thought non relational dbs idea originally developed response processing unstructured web based data httpswwwdataversityneta brief history non relational databases 5 cap theorem review 2 3 following consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 6 cap theorem review consistency availability responds latest data request gets response able deal network partitions consistency partition tolerance responds data distrib latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 7 acid alternative distrib systems base basically available guarantees availability data cap response failureunreliable data",
    "sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 7 acid alternative distrib systems base basically available guarantees availability data cap response failureunreliable data inconsistent changing state appears work time 8 acid alternative distrib systems base soft state state change time wo input changes result eventual consistency data stores dont write consistent replicas dont mutually consistent 9 acid alternative distrib systems base eventual consistency eventually consistent writes eventually stop nodesreplicas updated 10 categories nosql dbs review 11 key value databases 12 key value stores key value key value stores designed simplicity data model extremely simple comparatively tables rdbms complex lends simple crud ops api creation 13 key value stores key value key value stores designed speed usually deployed memory db retrieving value given key typically o1 op bc hash tables similar data structs used hood concept complex queries joins slow things 14 key value stores key value key value stores designed scalability horizontal scaling simple add nodes typically concerned eventual consistency meaning distributed environment guarantee nodes eventually converge value 15 kv ds use cases edaexperimentation results store store intermediate results data preprocessing eda store experiment testing ab results wo prod db feature store store frequently accessed feature low latency retrieval model training prediction model monitoring store key metrics performance model example real time inferencing 16 kv swe use cases storing session information current session stored single post retrieved single fast user profiles preferences user info obtained single operation language tz product ui preferences shopping cart data cart data tied user needs available browsers machines sessions caching layer disk based database 17 redis db redis remote directory server open source memory database called data structure store primarily kv store used models graph spatial text search vector time series db enginescom ranking kv stores 18 redis considered memory database supports durability",
    "partitioning nodes graph tendency strengthen break apart 18 centrality 19 famous graph algorithms dijkstras algorithm single source shortest path algo positively weighted graphs algorithm similar dijkstras added feature using heuristic guide traversal pagerank measures importance node graph based number incoming relationships importance nodes incoming relationships 20 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 21 22",
    "attempt credit money account 2 update accounts set balance balance account id receiver id continued slide 10 example transaction transfer continued previous slide check sufficient funds account 1 simulate condition insufficient funds select balance accounts account id sender id 0 roll transaction insufficient funds rollback signal sqlstate 45000 45000 unhandled user defined error set message text rollback message log transactions sufficient funds insert transactions account id transaction type values sender id withdrawal insert transactions account id transaction type values receiver id deposit commit transaction commit select commit message result end end delimiter 11 acid properties durability transaction completed committed successfully changes permanent event failure committed transactions preserved info transactions kleppmann book chapter 7 12 relational databases solution problems schemas evolve time apps need strength acid compliance joins expensive lot data semi structured unstructured json xml horizontal scaling presents challenges apps need performant real time low latency systems 13 scalability conventional wisdom scale vertically bigger powerful systems demands high availability make necessary scale type distributed computing model scaling easier need really modify architecture practical financial limits modern systems make horizontal scaling problematic 14 distributed data scaling distributed collection independent computers appear users computer andrew tennenbaum characteristics distributed systems computers operate concurrently computers fail independently shared global clock 15 distributed storage 2 directions single main node 16 distributed data stores data stored 1 node typically replicated block data available n nodes distributed databases relational non relational mysql postgresql support replication sharding cockroachdb new player scene nosql systems support models remember network partitioning inevitable network failures failures overall needs partition tolerant running w network partition 17 cap theorem 18 cap theorem cap theorem states impossible distributed data store simultaneously provide following guarantees consistency read receives recent write error thrown availability request receives non error response guarantee response contains",
    "ds 4300 introduction graph data model mark fontenot phd northeastern university material referenced graph algorithms practical examples apache spark neo4j needham hodler oreilly press 2019 graph database data model based graph data structure composed nodes edges edges connect nodes uniquely identified contain properties occupation supports queries based graph oriented operations traversals shortest path lots 2 graphs social networks yes things like instagram modeling social interactions fields like psychology sociology web just big graph pages nodes connected hyperlinks edges chemical biological data systems biology genetics interaction relationships chemistry 3 basics graphs graph theory 4 graph labeled property graph composed set node vertex objects relationship edge objects labels used mark node group properties attributes think kv pairs exist nodes relationships nodes associated relationships ok edges connected nodes permitted 5 example 2 labels person car 4 relationship types drives owns lives married properties 6 paths path ordered sequence nodes connected edges nodes edges repeated 3 1 2 ex 1 2 6 5 path 4 6 5 1 2 6 2 3 7 flavors graphs connected vs disconnected path nodes graph weighted vs unweighted edge weight property important algorithms directed vs undirected relationships edges define start end node acyclic vs cyclic graph contains cycles 8 connected vs disconnected 9 weighted vs unweighted 10 directed vs undirected 11 cyclic vs acyclic 12 sparse vs dense 13 trees 14 types graph algorithms pathfinding pathfinding finding shortest path nodes exists probably common operation shortest means fewest edges lowest weight average shortest path used monitor efficiency resiliency networks minimum spanning tree cycle detection maxmin flow types pathfinding 15 bfs vs dfs 16 shortest path 17 types graph algorithms centrality community detection centrality determining nodes important network compared nodes ex social network influencers community detection evaluate clustering partitioning nodes graph tendency strengthen break apart 18 centrality 19 famous graph algorithms dijkstras algorithm single source shortest path algo positively weighted graphs algorithm similar dijkstras added feature using heuristic guide traversal",
    "chapter 12 binary search trees binary search tree binary tree special property called bst property given follows nodes x y y belongs left subtree x key y key x y belongs right subtree x key y greater key x assume keys bst pairwise distinct node following attributes cid15 p left right pointers parent left child right child respectively cid15 key key stored node 1 example 7 4 12 2 6 9 19 3 5 8 11 15 20 2 traversal nodes bst traversal mean visiting nodes graph traversal strategies specicid12ed ordering objects visit current node left subtree right subtree assume left subtree comes right subtree strategies 1 inorder ordering left subtree current node right subtree 2 preorder ordering current node left subtree right subtree 3 postorder ordering left subtree right subtree current node 3 inorder traversal pseudocode recursive algorithm takes input pointer tree executed inorder traversal tree doing traversal prints key node visited inorder walk x nil 1 x return inorder walk 2 leftx 3 print keyx inorder walk 4 rightx write similar pseudocode preorder postorder 4 2 1 3 1 3 2 3 1 2 inorder preorder postorder 7 4 12 2 6 9 19 3 5 8 11 15 20 outcome inorder traversal bst postorder traversal preorder traversal 5 inorder traversal gives 2 3 4 5 6 7 8 9 11 12 15 19 20 preorder traversal gives 7 4 2 3 6 5 12 9 8 11 19 15 20 postorder traversal gives 3 2 5 6 4 8 11 9 15 20 19 12 7 inorder travel bst cid12nds keys nondecreasing order 6 operations bst 1 searching key assume key subtree key searched given input advantage bst property suppose node node key searched search key current node strictly smaller key searched strictly greater key searched",
    "general trade offs exist consistency availability performance indexing strategies significantly impact query performance nosql databases great unstructured data sacrifice strong consistency graph databases optimized relationships large scale storage retrieval foundations foundations large scale storage retrieval introduction information storage information retrieval ir process storing organizing retrieving data efficiently ir systems range search engines google databases storing medical records key challenges scalability handling petabytes data efficiency fast retrieval times google milliseconds consistency availability ensuring fault tolerance reliability searching strategies linear search simple inefficient time complexity binary search works sorted data olog n complexity indexing key making search efficient uses external data structures like b trees hash indexes indexing techniques hash indexing best unique lookups o1 average case b trees b trees used databases optimized disk access inverted index used search engines maps words documents record collection values attribues single entity instance row table collection set records entity type table trvially stored sequuential order like list search key value attribute entity type 1 attribute nx bytes memory record takes x bytes memory n records need contiguously allocated list nx byte allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses arrays faster random access inserting end slow linked lists faster inserting list random access slow linear search best case 1 worst case binary search best case 1 worst case log2n read code explain binary search isdoes binary search tree binary tree node left subtree parent node right parent avl tree approx balanced binary search tree maintains balance faster avl property hlst hrst 1 self balancing inserting imbalance ll lr rl rr trees b trees indexing b trees used database indexing filesystems ntfs postgresql indexes keeps tree height small reducing disk reads b trees vs b trees b trees store keys values internal leaf nodes b trees store values leaf nodes making range queries efficient bst properties left subtree values root right subtree values search time complexity olog n balanced unbalanced avl trees self balancing bst ensures olog n search time rotations used rebalancing ll rotation single right rotation rr rotation single left rotation",
    "range queries efficient bst properties left subtree values root right subtree values search time complexity olog n balanced unbalanced avl trees self balancing bst ensures olog n search time rotations used rebalancing ll rotation single right rotation rr rotation single left rotation lr rotation left right rotation rl rotation right left rotation sql vs sql sql structured query langage relational easy querying relationships data multiple datas acid compliant atomicity consistency isolation durability good storing querying unstructured data format unknown difficult scale horizontally nosql document keyvalue graph wide column stores flexible simpler set shard data different data stores allowing distributed databases making horizontal scaling easier large data stored designed distributed purposes optimistic concurrency assumes conflicts unlikely occur add updated timestamp version number columns table modified independently transactions relational databases vs nosql acid vs base acid ensures strong consistency atomicity transactions consistency data remains valid isolation transactions interfere durability committed stays committed base prioritizes availability consistency basically available soft state eventually consistent sql vs nosql feature sql relational nosql non relational schema fixed structured flexible dynamic scalability vertical scale horizontal scale consistency strong acid compliance eventual consistency examples mysql postgresql mongodb cassandra neo4j nosql cap theorem consistency nodes data simultaneously availability request gets response stale partition tolerance functions despite network failures nosql categories type example use case key value redis caching real time stores dynamodb analytics document mongodb json like flexible data stores couchdb models column stores apache time series analytics cassandra graph neo4j relationship heavy data databases graph data models neo4j graph theory basics nodes entities users products edges relationships nodes traversal algorithms bfs dfs dijkstras shortest path neo4j cypher neo4j acid compliant graph database cypher query examples match friend b return b data replication distributed systems improves fault tolerance node crashes serve data enables load balancing distribute requests multiple servers replication strategies master slave replication node handles writes replicate reads multi master replication multiple nodes accept writes requires conflict resolution eventual consistency updates propagate time used nosql systems like dynamodb"
  ],
  "config": {
    "chunk_size": 500,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0089,
    "llm_response_time_sec": 9.458,
    "memory_before_MB": 12.74,
    "memory_after_MB": 14.23
  }
}
{
  "question": "Succinctly describe the four components of ACID compliant transactions.",
  "llm_response": "1. Atomicity: A transaction is indivisible, meaning that it either succeeds entirely or fails entirely. If any part of a transaction fails, then the entire transaction should fail.\n\n2. Consistency: A transaction should not leave the database in an inconsistent state. This means that before and after a transaction, the database must meet certain integrity constraints, such as primary key constraints and referential integrity rules.\n\n3. Isolation: Each transaction is isolated from other transactions to ensure that they are executed independently. This prevents data conflicts between concurrent transactions.\n\n4. Durability: Once a transaction has been successfully committed, its changes must be persistent and permanent in the database. The database system should protect against system failures to ensure that the data remains safe even in the event of hardware or software malfunctions.",
  "context": [
    "partitioning nodes graph tendency strengthen break apart 18 centrality 19 famous graph algorithms dijkstras algorithm single source shortest path algo positively weighted graphs algorithm similar dijkstras added feature using heuristic guide traversal pagerank measures importance node graph based number incoming relationships importance nodes incoming relationships 20 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 21 22",
    "ds 4300 large scale information storage retrieval foundations mark fontenot phd northeastern university searching searching common operation performed database sql select statement arguably versatile complex baseline efficiency linear search start beginning list proceed element element youre looking element havent 2 searching record collection values attributes single entity instance row table collection set records entity type table trivially stored sequential order like list search key value attribute entity type 1 attribute 3 lists records record takes x bytes memory n records need nx bytes memory contiguously allocated list nx bytes allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses 4 contiguous vs linked 6 records contiguously allocated array extra storage memory address 6 records linked memory addresses linked list 5 pros cons arrays faster random access slow inserting end records insert 2nd record records 5 records moved make space linked lists faster inserting list slower random access insert 2nd record 6 observations arrays fast random access slow random insertions linked lists slow random access fast random insertions 7 binary search input array values sorted order target value output location index target located value indicating target def binary searcharr target left right 0 lenarr 1 left right left right c g m p r z target mid left right 2 arrmid target mid return mid target arrmid reset right mid 1 left right elif arrmid target left mid 1 c g m p r z target mid right mid 1 return 1 8 time complexity linear search best case target element 1 comparison worst case target array n comparisons worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog",
    "kv entry collection field value pairs use cases used represent basic objectsstructures number fieldvalue pairs hash 232 1 practical limit available resources memory session information management userevent tracking include ttl active session tracking sessions hash key 27 hash commands hset bike1 model demios brand ergonom price 1971 hget bike1 model hget bike1 price hgetall bike1 hmget bike1 model price weight returned hincrby bike1 price 100 28 list type value kv pair linked lists string values use cases implementation stacks queues queue management message passing queues producerconsumer model logging systems easy chronological order build social media streamsfeeds message history chat application batch processing queueing set tasks executed sequentially later time 29 linked lists crash course 10 nil sequential data structure linked nodes instead contiguously allocated memory node points element list points nilnull o1 insert new value insert new value end 30 list commands queue queue like ops lpush bikesrepairs bike1 lpush bikesrepairs bike2 rpop bikesrepairs rpop bilesrepairs 31 list commands stack stack like ops lpush bikesrepairs bike1 lpush bikesrepairs bike2 lpop bikesrepairs lpop bilesrepairs 32 list commands lpush mylist lpush mylist list ops lpush mylist llen mylist lrange key start stop lrange mylist 0 3 lrange mylist 0 0 lrange mylist 2 1 33 json type support json standard uses jsonpath syntax parsingnavigating json document internally stored binary tree structure fast access sub elements 34 set type unordered collection unique strings members use cases track unique items ip addresses visiting site page screen primitive relation set students ds4300 access control lists users permission structures social network friends lists andor group membership supports set operations 35 set commands sadd ds4300 mark sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam sismember ds4300 mark sismember ds4300 nick scard ds4300 36 sadd ds4300 mark set commands sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam scard ds4300 sinter ds4300 cs3200 sdiff ds4300 cs3200 srem ds4300 mark srandmember ds4300 37 38",
    "sequence writes happens certain order reading writes appear order 24 25",
    "ds 4300 introduction graph data model mark fontenot phd northeastern university material referenced graph algorithms practical examples apache spark neo4j needham hodler oreilly press 2019 graph database data model based graph data structure composed nodes edges edges connect nodes uniquely identified contain properties occupation supports queries based graph oriented operations traversals shortest path lots 2 graphs social networks yes things like instagram modeling social interactions fields like psychology sociology web just big graph pages nodes connected hyperlinks edges chemical biological data systems biology genetics interaction relationships chemistry 3 basics graphs graph theory 4 graph labeled property graph composed set node vertex objects relationship edge objects labels used mark node group properties attributes think kv pairs exist nodes relationships nodes associated relationships ok edges connected nodes permitted 5 example 2 labels person car 4 relationship types drives owns lives married properties 6 paths path ordered sequence nodes connected edges nodes edges repeated 3 1 2 ex 1 2 6 5 path 4 6 5 1 2 6 2 3 7 flavors graphs connected vs disconnected path nodes graph weighted vs unweighted edge weight property important algorithms directed vs undirected relationships edges define start end node acyclic vs cyclic graph contains cycles 8 connected vs disconnected 9 weighted vs unweighted 10 directed vs undirected 11 cyclic vs acyclic 12 sparse vs dense 13 trees 14 types graph algorithms pathfinding pathfinding finding shortest path nodes exists probably common operation shortest means fewest edges lowest weight average shortest path used monitor efficiency resiliency networks minimum spanning tree cycle detection maxmin flow types pathfinding 15 bfs vs dfs 16 shortest path 17 types graph algorithms centrality community detection centrality determining nodes important network compared nodes ex social network influencers community detection evaluate clustering partitioning nodes graph tendency strengthen break apart 18 centrality 19 famous graph algorithms dijkstras algorithm single source shortest path algo positively weighted graphs algorithm similar dijkstras added feature using heuristic guide traversal",
    "ds 4300 document databases mongodb mark fontenot phd northeastern university material used permission dr rachlin thanks document database document database non relational database stores data structured documents usually json designed simple flexible scalable 2 json json javascript object notation lightweight data interchange format easy humans read write easy machines parse generate json built structures collection namevalue pairs various languages operationalized object record struct dictionary hash table keyed list associative array ordered list values languages operationalized array vector list sequence universal data structures supported virtually modern programming languages json makes great data interchange format 3 json syntax httpswwwjsonorgjson enhtml 4 binary json bson bson binary json binary encoded serialization json like document structure supports extended types basic json date binarydata lightweight space overhead minimum traversable designed easily traversed vitally important document db efficient encoding decoding efficient supported modern programming languages 5 xml extensible markup language precursor json data exchange format xml css web pages separated content formatting structurally similar html tag set extensible 6 xml related toolstechnologies xpath syntax retrieving specific elements xml doc xquery query language interrogating xml documents sql xml dtd document type definition language describing allowed structure xml document xslt extensible stylesheet language transformation tool transform xml formats including non xml formats html 7 document databases document databases address impedance mismatch problem object persistence oo systems relational dbs structure data oo programming inheritance composition types save complex object relational database basically deconstruct structure document self describing aligned apps use jsonxml transport layer 8 mongodb 9 mongodb started 2007 doubleclick acquired google 3 veterans realized limitations relational databases serving 400000 ads second mongodb short humongous database mongodb atlas released 2016 documentdb service httpswwwmongodbcomcompanyour story 10 mongodb structure database collection collection b collection c document 1 document 1 document 1 document 2 document 2 document 2 document 3 document 3 document 3 11 mongodb documents predefined schema documents needed document collection different dataschema",
    "assumes conflicts occur uses locks optimistic concurrency locks assumes conflicts rare uses timestamps version numbers good read heavy systems efficient high conflict systems base alternative acid distributed systems basically available works time soft state state change input eventual consistency eventually reach consistency 8 key value databases design principles simplicity extremely simple data model compared rdbms speed memory o1 retrieval operations scalability easy horizontal scaling eventual consistency use cases data science experiment results storage feature storage model monitoring software engineering session information user profiles shopping carts caching 9 redis key value database open source memory database high performance 100000 set opssecond supports data durability snapshots append journals simple lookup key secondary indexes data types strings basic textbinary data lists linked lists queuesstacks sets unique unordered string collections hashes field value collections sorted sets sets scores ordering specialized types geospatial data json common operations basic crud set exists del atomic counters incr incrby decr decrby list operations lpush rpush lpop rpop llen lrange set operations sadd scard sismember sinter sdiff hash operations hset hget hgetall",
    "worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog n time 2 complexity 9 database searching assume data stored disk column ids value searching specific id fast want search specific specialval option linear scan column store data disk sorted id specialval time data duplicated space inefficient 10 database searching assume data stored disk column ids value searching specific id fast want search specific need external data structure specialval support faster searching option linear scan column specialval linear scan store data disk sorted id specialval time data duplicated space inefficient 11 arsenal 1 array tuples specialval rownumber sorted specialval use binary search quickly locate particular specialval corresponding row table b insert table like inserting sorted array slow 2 linked list tuples specialval rownumber sorted specialval searching specialval slow linear scan required b inserting table theoretically quick add list 12 fast insert fast search binary search tree binary tree node left subtree parent node right subtree greater parent image httpscoursesgraingerillinoiseducs225sp2019notesbst 13 board 14",
    "ds 4300 large scale information storage retrieval mark fontenot phd northeastern university hi mark fontenot phd office 353 meserve hall office hours m th 130 300 pm times dont work just dm slack set alternate time usually available slack just dm mfontenotnortheasternedu 2 teaching assistants iker acosta venegas dallon archibald nathan cheung aryan jain sevinch noori abhishek kumar eddy liu junxiang lin 3 course materials notes assignments httpsmarkfontenotnetteachingds430025s ds4300 assignment submissions grades gradescope q platform campuswire quick dms announcements slack 4 whats class end class understand efficiency related concepts including limitations rdbmss understand data replication distribution effects typical db usage scenarios understand use cases data models various nosql database systems including storing retrieving data data models include document based key value stores graph based access implement data engineering big data related aws services 5 course deliverables evaluation 6 assignments homeworks practicals usually tuesday nights 1159 unless stated 3 bonus submitting 48 hours early 3 submitting 48 hours early late submissions accepted life happens gets 1 free questions asked 48 hour extension dm dr fontenot slack original deadline requesting use extension 7 assignments submissions gradescope andor github unless directed submit pdfs unless instructed submitting pdf sure associate questions gradescope correct page pdf failure result grade 0 assignment regrade requests submitted 48 hours grades released gradescope exceptions 8 midterm monday march 17 mark calendars 9 final grade breakdown homeworks 5 30 practicals 2 20 midterm 20 semester project 30 10 reference materials primary resources books playlist add additional materials playlist webpage semester progresses oreilly playlist 11 tentative list topics thinking data storage retrieval data structures level far relational model nosql databases document databases mongo graph databases neo4j keyvalue databases maybe vector databases data distribution replication distributed sql dbs apache sparksparksql big data tools services aws 12 tools need install laptop docker desktop anaconda miniconda python youre welcome use distro youre responsible fixing doesnt work dependency conflicts database access tool like datagrip",
    "sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 7 acid alternative distrib systems base basically available guarantees availability data cap response failureunreliable data inconsistent changing state appears work time 8 acid alternative distrib systems base soft state state change time wo input changes result eventual consistency data stores dont write consistent replicas dont mutually consistent 9 acid alternative distrib systems base eventual consistency eventually consistent writes eventually stop nodesreplicas updated 10 categories nosql dbs review 11 key value databases 12 key value stores key value key value stores designed simplicity data model extremely simple comparatively tables rdbms complex lends simple crud ops api creation 13 key value stores key value key value stores designed speed usually deployed memory db retrieving value given key typically o1 op bc hash tables similar data structs used hood concept complex queries joins slow things 14 key value stores key value key value stores designed scalability horizontal scaling simple add nodes typically concerned eventual consistency meaning distributed environment guarantee nodes eventually converge value 15 kv ds use cases edaexperimentation results store store intermediate results data preprocessing eda store experiment testing ab results wo prod db feature store store frequently accessed feature low latency retrieval model training prediction model monitoring store key metrics performance model example real time inferencing 16 kv swe use cases storing session information current session stored single post retrieved single fast user profiles preferences user info obtained single operation language tz product ui preferences shopping cart data cart data tied user needs available browsers machines sessions caching layer disk based database 17 redis db redis remote directory server open source memory database called data structure store primarily kv store used models graph spatial text search vector time series db enginescom ranking kv stores 18 redis considered memory database supports durability"
  ],
  "config": {
    "chunk_size": 500,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0079,
    "llm_response_time_sec": 15.119,
    "memory_before_MB": 12.48,
    "memory_after_MB": 14.01
  }
}
{
  "question": "5. What is disk-based indexing and why is it important for database systems?",
  "llm_response": "Disk-based indexing is a method used in database systems to improve the efficiency of data retrieval from disk storage. It involves organizing data into an index, which is a separate file or structure that stores pointers or metadata about the location of specific data items on the disk.\n\nThe importance of disk-based indexing lies in its ability to reduce the time required to search for and retrieve data from disk storage. Without indexing, the database would have to scan through the entire data file to find a specific piece of information, which could be extremely slow and inefficient, especially for large datasets. With an index, the database can quickly locate the position on the disk where the requested data is stored, without having to scan through the entire file. This leads to faster query performance and overall improved system efficiency.\n\nMoreover, disk-based indexing also supports advanced search functionality, such as sorting, filtering, and joining data based on various attributes or criteria. This makes it easier for users to retrieve specific data and perform complex queries without having to manually scan through large amounts of data.",
  "context": [
    "sequence writes happens certain order reading writes appear order 24 25",
    "kv entry collection field value pairs use cases used represent basic objectsstructures number fieldvalue pairs hash 232 1 practical limit available resources memory session information management userevent tracking include ttl active session tracking sessions hash key 27 hash commands hset bike1 model demios brand ergonom price 1971 hget bike1 model hget bike1 price hgetall bike1 hmget bike1 model price weight returned hincrby bike1 price 100 28 list type value kv pair linked lists string values use cases implementation stacks queues queue management message passing queues producerconsumer model logging systems easy chronological order build social media streamsfeeds message history chat application batch processing queueing set tasks executed sequentially later time 29 linked lists crash course 10 nil sequential data structure linked nodes instead contiguously allocated memory node points element list points nilnull o1 insert new value insert new value end 30 list commands queue queue like ops lpush bikesrepairs bike1 lpush bikesrepairs bike2 rpop bikesrepairs rpop bilesrepairs 31 list commands stack stack like ops lpush bikesrepairs bike1 lpush bikesrepairs bike2 lpop bikesrepairs lpop bilesrepairs 32 list commands lpush mylist lpush mylist list ops lpush mylist llen mylist lrange key start stop lrange mylist 0 3 lrange mylist 0 0 lrange mylist 2 1 33 json type support json standard uses jsonpath syntax parsingnavigating json document internally stored binary tree structure fast access sub elements 34 set type unordered collection unique strings members use cases track unique items ip addresses visiting site page screen primitive relation set students ds4300 access control lists users permission structures social network friends lists andor group membership supports set operations 35 set commands sadd ds4300 mark sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam sismember ds4300 mark sismember ds4300 nick scard ds4300 36 sadd ds4300 mark set commands sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam scard ds4300 sinter ds4300 cs3200 sdiff ds4300 cs3200 srem ds4300 mark srandmember ds4300 37 38",
    "ds 4300 large scale information storage retrieval mark fontenot phd northeastern university hi mark fontenot phd office 353 meserve hall office hours m th 130 300 pm times dont work just dm slack set alternate time usually available slack just dm mfontenotnortheasternedu 2 teaching assistants iker acosta venegas dallon archibald nathan cheung aryan jain sevinch noori abhishek kumar eddy liu junxiang lin 3 course materials notes assignments httpsmarkfontenotnetteachingds430025s ds4300 assignment submissions grades gradescope q platform campuswire quick dms announcements slack 4 whats class end class understand efficiency related concepts including limitations rdbmss understand data replication distribution effects typical db usage scenarios understand use cases data models various nosql database systems including storing retrieving data data models include document based key value stores graph based access implement data engineering big data related aws services 5 course deliverables evaluation 6 assignments homeworks practicals usually tuesday nights 1159 unless stated 3 bonus submitting 48 hours early 3 submitting 48 hours early late submissions accepted life happens gets 1 free questions asked 48 hour extension dm dr fontenot slack original deadline requesting use extension 7 assignments submissions gradescope andor github unless directed submit pdfs unless instructed submitting pdf sure associate questions gradescope correct page pdf failure result grade 0 assignment regrade requests submitted 48 hours grades released gradescope exceptions 8 midterm monday march 17 mark calendars 9 final grade breakdown homeworks 5 30 practicals 2 20 midterm 20 semester project 30 10 reference materials primary resources books playlist add additional materials playlist webpage semester progresses oreilly playlist 11 tentative list topics thinking data storage retrieval data structures level far relational model nosql databases document databases mongo graph databases neo4j keyvalue databases maybe vector databases data distribution replication distributed sql dbs apache sparksparksql big data tools services aws 12 tools need install laptop docker desktop anaconda miniconda python youre welcome use distro youre responsible fixing doesnt work dependency conflicts database access tool like datagrip",
    "ds 4300 neo4j mark fontenot phd northeastern university material referenced graph algorithms practical examples apache spark neo4j needham hodler oreilly press 2019 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 2 neo4j query language plugins cypher neo4js graph query language created 2011 goal sql equivalent language graph databases provides visual way matching patterns relationships nodes connect othernodes apoc plugin awesome procedures cypher add library provides hundreds procedures functions graph data science plugin provides efficient implementations common graph algorithms like ones talked yesterday 3 neo4j docker compose 4 docker compose supports multi container management set declarative using yaml docker composeyaml file services volumes networks 1 command used start stop scale number services time provides consistent method producing identical environment works machine interaction command line 5 docker composeyaml services secrets neo4j container neo4j docker compose file use env image neo4jlatest ports files 74747474 76877687 environment neo4j authneo4jneo4j password neo4j apoc export file enabledtrue neo4j apoc import file enabledtrue neo4j apoc import file use neo4j configtrue neo4j pluginsapoc graph data science volumes neo4j dbdatadata neo4j dblogslogs neo4j dbimportvarlibneo4jimport neo4j dbpluginsplugins 6 env files env files stores collection environment variables good way environment variables different platforms separate envlocal env file envdev envprod neo4j passwordabc123 7 docker compose commands test docker cli properly installed run docker version major docker commands docker compose docker compose d docker compose docker compose start docker compose stop docker compose build docker compose build cache 8 localhost7474 9 neo4j browser localhost7474 login httpsneo4jcomdocsbrowser manualcurrentvisual tour 10 inserting data creating nodes create user alice birthplace paris create user bob birthplace london create user carol birthplace london create user dave birthplace london create user eve birthplace rome 11 adding edge variable names create user alice birthplace paris create user bob birthplace london match aliceuser namealice match bobuser bob create alice knows 2022 12 01 bob note relationships directed neo4j 12 matching users born london match usruser birthplace london return usrname usrbirthplace 13 download dataset import folder clone repo httpsgithubcompacktpublishinggraph data science neo4j chapter02data data repo unzip netflixzip file copy netflix titlescsv following folder docker compose file neo4j dbneo4j dbimport 14 importing data 15 basic data importing type following cypher editor",
    "tools services aws 12 tools need install laptop docker desktop anaconda miniconda python youre welcome use distro youre responsible fixing doesnt work dependency conflicts database access tool like datagrip dbeaver vs code set python development info vscode python anaconda ability interact git github terminal gui app 13 topics review days shellcmd promptpowershell cli windows want unix terminal wsl2 zsh windows navigating file running commands like pip conda python command line args docker docker compose basics dockerfiles docker composeyaml files port mapping setting volumes mapping host guest os 14 python rusty havent ton python crash course net ninja yt oreilly python section class playlist python object oriented programming video course simon sez e matthes python crash course 3rd edition starch press related yt video playlist listed 15 expectations conduct respectfully dont distract classmates learning dont cheat work unless group assignment discussing problems encouraged formulate solutions syllabus details 16 lets gooo 17",
    "ds 4300 redis python mark fontenot phd northeastern university redis py redis py standard client python maintained redis company github repo redisredis py 4300 conda environment pip install redis 2 connecting server import redis redis client redisredishostlocalhost port6379 db2 decode responsestrue docker deployment host localhost 127001 port port mapping given created container probably default 6379 db database 0 15 want connect decode responses data comes server bytes setting true converter decodes strings 3 redis command list list use filter command particular data structure youre targeting list hash set redispy documentation slides meant exhaustive list commands highlights check documentation complete list 4 string commands r represents redis client object rsetclickcountabc 0 val rgetclickcountabc rincrclickcountabc ret val rgetclickcountabc printfclick count ret val 5 string commands 2 r represents redis client object redis clientmsetkey1 val1 key2 val2 key3 val3 printredis clientmgetkey1 key2 key3 returns list val1 val2 val3 6 string commands 3 set mset setex msetnx setnx mget getex getdel incr decr incrby decrby strlen append 7 list commands 1 create list key names values mark sam nick redis clientrpushnames mark sam nick prints mark sam nick printredis clientlrangenames 0 1 8 list commands 2 lpush lpop lset lrem rpush rpop lrange llen lpos commands include moving elements lists popping multiple lists time 9 hash commands 1 redis clienthsetuser session123 mappingfirst sam uelle company redis age 30 prints sam surname uelle company redis age 30 printredis clienthgetalluser session123 10 hash commands 2 hset hget hgetall hkeys hdel hexists hlen hstrlen 11 redis pipelines helps avoid multiple related calls server network overhead r redisredisdecode responsestrue pipe rpipeline range5 pipesetfseati fi set 5 result pipeexecute printset 5 result true true true true true pipe rpipeline chain pipeline commands 3 result pipegetseat0getseat3getseat4execute printget 3 result 0 3 4 12 redis context 13 redis ml simplified example source httpswwwfeatureformcompostfeature stores explained common architectures 14 redis dsml source httpsmadewithmlcomcoursesmlopsfeature store 15",
    "ds 4300 nosql kv dbs mark fontenot phd northeastern university material used permission dr rachlin thanks distributed dbs acid pessimistic concurrency acid transactions focuses data safety considered pessimistic concurrency model assumes transaction protect transactions iow assumes wrong conflicts prevented locking resources transaction complete read write locks write lock analogy borrowing book library httpswwwfreecodecamporgnewshow databases guarantee isolation deeper dive 2 optimistic concurrency transactions obtain locks data read write optimistic assumes conflicts unlikely occur conflict ok add update timestamp version number columns table read changing check end transaction transaction caused modified 3 optimistic concurrency low conflict systems backups analytical dbs read heavy systems conflicts arise handled rolling running transaction notices conflict optimistic concurrency works allows higher concurrency high conflict systems rolling rerunning transactions encounter conflict efficient locking scheme pessimistic model preferable 4 nosql nosql used 1998 carlo strozzi relational database did use sql common modern meaning sql thought non relational dbs idea originally developed response processing unstructured web based data httpswwwdataversityneta brief history non relational databases 5 cap theorem review 2 3 following consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 6 cap theorem review consistency availability responds latest data request gets response able deal network partitions consistency partition tolerance responds data distrib latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 7 acid alternative distrib systems base basically available guarantees availability data cap response failureunreliable data",
    "ds 4300 large scale information storage retrieval foundations mark fontenot phd northeastern university searching searching common operation performed database sql select statement arguably versatile complex baseline efficiency linear search start beginning list proceed element element youre looking element havent 2 searching record collection values attributes single entity instance row table collection set records entity type table trivially stored sequential order like list search key value attribute entity type 1 attribute 3 lists records record takes x bytes memory n records need nx bytes memory contiguously allocated list nx bytes allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses 4 contiguous vs linked 6 records contiguously allocated array extra storage memory address 6 records linked memory addresses linked list 5 pros cons arrays faster random access slow inserting end records insert 2nd record records 5 records moved make space linked lists faster inserting list slower random access insert 2nd record 6 observations arrays fast random access slow random insertions linked lists slow random access fast random insertions 7 binary search input array values sorted order target value output location index target located value indicating target def binary searcharr target left right 0 lenarr 1 left right left right c g m p r z target mid left right 2 arrmid target mid return mid target arrmid reset right mid 1 left right elif arrmid target left mid 1 c g m p r z target mid right mid 1 return 1 8 time complexity linear search best case target element 1 comparison worst case target array n comparisons worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog",
    "database called data structure store primarily kv store used models graph spatial text search vector time series db enginescom ranking kv stores 18 redis considered memory database supports durability data essentially saving snapshots disk specific intervals b append file journal changes used roll forward failure originally developed 2009 c fast 100000 set ops second rich collection commands does handle complex data secondary indexes supports lookup key 19 redis data types keys usually strings binary sequence values strings lists linked lists sets unique unsorted string elements sorted sets hashes string string geospatial data 20 setting redis docker docker desktop search redis pullrun latest image optional settings add 6379 ports expose port connect normally expose redis port security reasons did prod environment major security hole notice didnt set password 21 connecting datagrip file new data source redis data source make sure port 6379 test connection 22 redis database interaction redis provides 16 databases default numbered 0 15 associated direct interaction redis set commands related setting getting kv pairs variations language libraries available 23 foundation data type string sequence bytes text serialized objects bin arrays simplest data type maps string string use cases caching frequently accessed htmlcssjs fragments config settings user settings info token management counting web pageapp screen views rate limiting 24 initial basic commands set pathtoresource 0 set user1 john doe pathtoresource exists user1 del user1 keys user select 5 select different database 25 basic commands set somevalue 0 incr somevalue increment 1 incrby somevalue 10 increment 10 decr somevalue decrement 1 decrby somevalue 5 decrement 5 incr parses value int increments adds value setnx key value sets value key key does exist 26 hash type value kv entry collection field value pairs use cases used represent basic objectsstructures number fieldvalue pairs hash 232 1 practical limit available resources memory session information management userevent tracking include ttl active session tracking",
    "assumes conflicts occur uses locks optimistic concurrency locks assumes conflicts rare uses timestamps version numbers good read heavy systems efficient high conflict systems base alternative acid distributed systems basically available works time soft state state change input eventual consistency eventually reach consistency 8 key value databases design principles simplicity extremely simple data model compared rdbms speed memory o1 retrieval operations scalability easy horizontal scaling eventual consistency use cases data science experiment results storage feature storage model monitoring software engineering session information user profiles shopping carts caching 9 redis key value database open source memory database high performance 100000 set opssecond supports data durability snapshots append journals simple lookup key secondary indexes data types strings basic textbinary data lists linked lists queuesstacks sets unique unordered string collections hashes field value collections sorted sets sets scores ordering specialized types geospatial data json common operations basic crud set exists del atomic counters incr incrby decr decrby list operations lpush rpush lpop rpop llen lrange set operations sadd scard sismember sinter sdiff hash operations hset hget hgetall"
  ],
  "config": {
    "chunk_size": 500,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0096,
    "llm_response_time_sec": 17.3562,
    "memory_before_MB": 10.18,
    "memory_after_MB": 11.87
  }
}
{
  "question": "When are linked lists faster than contiguously-allocated lists?",
  "llm_response": "Linked lists can be faster in certain scenarios where the elements within the list are frequently added or removed, as inserting or deleting an element in a contiguous array requires shifting all subsequent elements, which has a time complexity of O(n). In contrast, inserting or deleting an element in a linked list only requires rearranging pointers (O(1) time complexity in the average case). However, if the list is mostly accessed sequentially and seldom modified, contiguous arrays can provide faster access due to their random access feature with constant time complexity O(1), whereas accessing an element in a linked list involves traversing through the list which has a worst-case time complexity of O(n).\n\nTherefore, when dealing with data structures where frequent insertions and deletions are expected, such as message passing queues or undo/redo systems in a text editor, linked lists can offer performance benefits. On the other hand, for tasks involving extensive read operations on static data, contiguous arrays might be more efficient due to their constant time complexity for random access.",
  "context": [
    "sequence writes happens certain order reading writes appear order 24 25",
    "chapter 12 binary search trees binary search tree binary tree special property called bst property given follows nodes x y y belongs left subtree x key y key x y belongs right subtree x key y greater key x assume keys bst pairwise distinct node following attributes cid15 p left right pointers parent left child right child respectively cid15 key key stored node 1 example 7 4 12 2 6 9 19 3 5 8 11 15 20 2 traversal nodes bst traversal mean visiting nodes graph traversal strategies specicid12ed ordering objects visit current node left subtree right subtree assume left subtree comes right subtree strategies 1 inorder ordering left subtree current node right subtree 2 preorder ordering current node left subtree right subtree 3 postorder ordering left subtree right subtree current node 3 inorder traversal pseudocode recursive algorithm takes input pointer tree executed inorder traversal tree doing traversal prints key node visited inorder walk x nil 1 x return inorder walk 2 leftx 3 print keyx inorder walk 4 rightx write similar pseudocode preorder postorder 4 2 1 3 1 3 2 3 1 2 inorder preorder postorder 7 4 12 2 6 9 19 3 5 8 11 15 20 outcome inorder traversal bst postorder traversal preorder traversal 5 inorder traversal gives 2 3 4 5 6 7 8 9 11 12 15 19 20 preorder traversal gives 7 4 2 3 6 5 12 9 8 11 19 15 20 postorder traversal gives 3 2 5 6 4 8 11 9 15 20 19 12 7 inorder travel bst cid12nds keys nondecreasing order 6 operations bst 1 searching key assume key subtree key searched given input advantage bst property suppose node node key searched search key current node strictly smaller key searched strictly greater key searched case bst property keys th left subtree strictly key searched means need search left subtree examine right subtree case symmetry examine right subtree 7 algorithm k key searched x start node bst search x k 1 y x nil 2 y 6 3 keyy k return y 4 keyy k y righty 5 y lefty 6 return 8 example 7 search 8 4 11 2 6 9 13 nil running time search 9 2 maximum minimum cid12nd minimum identify leftmost node farthest node reach following left branches cid12nd maximum identify rightmost node farthest node reach following right branches bst minimum x nil 1 x return tree 2 y x nil 3 lefty 6 y lefty 4 return keyy bst maximum x nil 1 x return tree 2 y x nil 3 righty 6 y righty 4 return keyy 10 3 insertion suppose need insert node z k keyz using binary search cid12nd nil replacing z does break bst property 11 bst insert x z k nil 1 x return error 2 y x true 3 f 4 keyy k 5 z lefty 6 z righty nil 7 z break 8 g 9 keyy k lefty z 10 rightpy z 12 4 successor predecessor successor respectively predecessor key k search tree smallest respectively largest key belongs tree strictly greater respectively k idea cid12nding successor given node x cid15 x right child successor minimum right subtree x cid15 successor parent farthest node reached x following right branches backward 13 example 23 25 7 4 12 2 6 9 19 3 5 8 11 15 20 14 algorithm bst successor x nil 1 rightx 6 2 f y rightx nil 3 lefty 6 y lefty 4 return y g 5 6 f y x 7 rightpx x y px nil 8 px 6 return px 9 return successor g 15 predecessor similarly",
    "ds 4300 large scale information storage retrieval foundations mark fontenot phd northeastern university searching searching common operation performed database sql select statement arguably versatile complex baseline efficiency linear search start beginning list proceed element element youre looking element havent 2 searching record collection values attributes single entity instance row table collection set records entity type table trivially stored sequential order like list search key value attribute entity type 1 attribute 3 lists records record takes x bytes memory n records need nx bytes memory contiguously allocated list nx bytes allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses 4 contiguous vs linked 6 records contiguously allocated array extra storage memory address 6 records linked memory addresses linked list 5 pros cons arrays faster random access slow inserting end records insert 2nd record records 5 records moved make space linked lists faster inserting list slower random access insert 2nd record 6 observations arrays fast random access slow random insertions linked lists slow random access fast random insertions 7 binary search input array values sorted order target value output location index target located value indicating target def binary searcharr target left right 0 lenarr 1 left right left right c g m p r z target mid left right 2 arrmid target mid return mid target arrmid reset right mid 1 left right elif arrmid target left mid 1 c g m p r z target mid right mid 1 return 1 8 time complexity linear search best case target element 1 comparison worst case target array n comparisons worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog n time 2 complexity 9 database searching assume data stored disk column ids value searching specific id fast want search specific specialval option linear scan column store data disk sorted id specialval time data duplicated space inefficient 10 database searching assume data stored disk column ids value searching specific id fast want search specific need external data structure specialval support faster searching option linear scan column specialval linear scan store data disk sorted id specialval time data duplicated space inefficient 11 arsenal 1 array tuples specialval rownumber sorted specialval use binary search quickly locate particular specialval corresponding row table b insert table like inserting sorted array slow 2 linked list tuples specialval rownumber sorted specialval searching specialval slow linear scan required b inserting table theoretically quick add list 12 fast insert fast search binary search tree binary tree node left subtree parent node right subtree greater parent image httpscoursesgraingerillinoiseducs225sp2019notesbst 13 board 14",
    "ds 4300 large scale information storage retrieval mark fontenot phd northeastern university hi mark fontenot phd office 353 meserve hall office hours m th 130 300 pm times dont work just dm slack set alternate time usually available slack just dm mfontenotnortheasternedu 2 teaching assistants iker acosta venegas dallon archibald nathan cheung aryan jain sevinch noori abhishek kumar eddy liu junxiang lin 3 course materials notes assignments httpsmarkfontenotnetteachingds430025s ds4300 assignment submissions grades gradescope q platform campuswire quick dms announcements slack 4 whats class end class understand efficiency related concepts including limitations rdbmss understand data replication distribution effects typical db usage scenarios understand use cases data models various nosql database systems including storing retrieving data data models include document based key value stores graph based access implement data engineering big data related aws services 5 course deliverables evaluation 6 assignments homeworks practicals usually tuesday nights 1159 unless stated 3 bonus submitting 48 hours early 3 submitting 48 hours early late submissions accepted life happens gets 1 free questions asked 48 hour extension dm dr fontenot slack original deadline requesting use extension 7 assignments submissions gradescope andor github unless directed submit pdfs unless instructed submitting pdf sure associate questions gradescope correct page pdf failure result grade 0 assignment regrade requests submitted 48 hours grades released gradescope exceptions 8 midterm monday march 17 mark calendars 9 final grade breakdown homeworks 5 30 practicals 2 20 midterm 20 semester project 30 10 reference materials primary resources books playlist add additional materials playlist webpage semester progresses oreilly playlist 11 tentative list topics thinking data storage retrieval data structures level far relational model nosql databases document databases mongo graph databases neo4j keyvalue databases maybe vector databases data distribution replication distributed sql dbs apache sparksparksql big data tools services aws 12 tools need install laptop docker desktop anaconda miniconda python youre welcome use distro youre responsible fixing doesnt work dependency conflicts database access tool like datagrip dbeaver vs code set python development info vscode python anaconda ability interact git github terminal gui app 13 topics review days shellcmd promptpowershell cli windows want unix terminal wsl2 zsh windows navigating file running commands like pip conda python command line args docker docker compose basics dockerfiles docker composeyaml files port mapping setting volumes mapping host guest os 14 python rusty havent ton python crash course net ninja yt oreilly python section class playlist python object oriented programming video course simon sez e matthes python crash course 3rd edition starch press related yt video playlist listed 15 expectations conduct respectfully dont distract classmates learning dont cheat work unless group assignment discussing problems encouraged formulate solutions syllabus details 16 lets gooo 17",
    "general trade offs exist consistency availability performance indexing strategies significantly impact query performance nosql databases great unstructured data sacrifice strong consistency graph databases optimized relationships large scale storage retrieval foundations foundations large scale storage retrieval introduction information storage information retrieval ir process storing organizing retrieving data efficiently ir systems range search engines google databases storing medical records key challenges scalability handling petabytes data efficiency fast retrieval times google milliseconds consistency availability ensuring fault tolerance reliability searching strategies linear search simple inefficient time complexity binary search works sorted data olog n complexity indexing key making search efficient uses external data structures like b trees hash indexes indexing techniques hash indexing best unique lookups o1 average case b trees b trees used databases optimized disk access inverted index used search engines maps words documents record collection values attribues single entity instance row table collection set records entity type table trvially stored sequuential order like list search key value attribute entity type 1 attribute nx bytes memory record takes x bytes memory n records need contiguously allocated list nx byte allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses arrays faster random access inserting end slow linked lists faster inserting list random access slow linear search best case 1 worst case binary search best case 1 worst case log2n read code explain binary search isdoes binary search tree binary tree node left subtree parent node right parent avl tree approx balanced binary search tree maintains balance faster avl property hlst hrst 1 self balancing inserting imbalance ll lr rl rr trees b trees indexing b trees used database indexing filesystems ntfs postgresql indexes keeps tree height small reducing disk reads b trees vs b trees b trees store keys values internal leaf nodes b trees store values leaf nodes making range queries efficient bst properties left subtree values root right subtree values search time complexity olog n balanced unbalanced avl trees self balancing bst ensures olog n search time rotations used rebalancing ll rotation single right rotation rr rotation single left rotation lr rotation left right rotation rl rotation right left rotation sql vs sql sql structured query langage relational easy querying relationships data multiple datas acid compliant atomicity consistency isolation durability good storing querying unstructured data format unknown difficult scale horizontally nosql document keyvalue graph wide column stores flexible simpler set shard data different data stores allowing distributed databases making horizontal scaling easier large data stored designed distributed purposes optimistic concurrency assumes conflicts unlikely occur add updated timestamp version number columns table modified independently transactions relational databases vs nosql acid vs base acid ensures strong consistency atomicity transactions consistency data remains valid isolation transactions interfere durability committed stays committed base prioritizes availability consistency basically available soft state eventually consistent sql vs nosql feature sql relational nosql non relational schema fixed structured flexible dynamic scalability vertical scale horizontal scale consistency strong acid compliance eventual consistency examples mysql postgresql mongodb cassandra neo4j nosql cap theorem consistency nodes data simultaneously availability request gets response stale partition tolerance functions despite network failures nosql categories type example use case key value redis caching real time stores dynamodb analytics document mongodb json like flexible data stores couchdb models column stores apache time series analytics cassandra graph neo4j relationship heavy data databases graph data models neo4j graph theory basics nodes entities users products edges relationships nodes traversal algorithms bfs dfs dijkstras shortest path neo4j cypher neo4j acid compliant graph database cypher query examples match friend b return b data replication distributed systems improves fault tolerance node crashes serve data enables load balancing distribute requests multiple servers replication strategies master slave replication node handles writes replicate reads multi master replication multiple nodes accept writes requires conflict resolution eventual consistency updates propagate time used nosql systems like dynamodb",
    "random variables x convex function f fex cid20 efx x let x x fx 2 n efx ey n 1 n 3 ex 2 n cid20 cid16 cid17 4 3 3 right hand n 3 taking log sides ex olog n n average height randomly build bst olog n 26",
    "parent farthest node reached x following right branches backward 13 example 23 25 7 4 12 2 6 9 19 3 5 8 11 15 20 14 algorithm bst successor x nil 1 rightx 6 2 f y rightx nil 3 lefty 6 y lefty 4 return y g 5 6 f y x 7 rightpx x y px nil 8 px 6 return px 9 return successor g 15 predecessor similarly roles left right exchanged roles maximum minimum exchanged node successor undecid12ned running time successor algorithm 16 5 deletion suppose want delete node z 1 z children just nil replace z 2 z child promote unique child zs place 3 z children identify zs successor y successor y leaf right child promote y zs place treat loss y using solutions 17 8 8 5 11 5 11 1 6 9 13 1 6 9 13 3 7 10 3 10 2 4 2 4 8 8 5 11 5 11 1 6 9 13 3 6 9 13 3 7 10 2 4 7 10 2 4 8 9 5 11 5 11 1 6 9 13 1 6 10 13 3 7 10 3 2 4 2 4 18 algorithm algorithm deletes z bst t bst delete t z nil nil 1 leftz rightz 2 y z bst successor 3 y z 4 cid3 y node thats actually removed 5 cid3 y does children nil 6 lefty 6 7 x lefty 8 x righty 9 cid3 x node thats moving ys position nil 10 x 6 px py 11 cid3 px reset x isnt nil 12 cid3 resetting unnecessary x nil 19 algorithm contd nil 13 py roott x 14 cid3 y root x root 15 cid3 following 16 y leftpy 17 leftpy x 18 cid3 y left child parent 19 cid3 set parents left child x 20 rightpy x 21 cid3 y right child parent 22 cid3 set parents right child x 23 y 6 z 24 f keyz keyy 25 data y z g 27 return y 20 summary ecid14ciency analysis theorem binary search tree search minimum maximum height h successor predecessor insert delete run oh time 21 randomly built bst suppose insert n distinct keys initially tree assuming n permutations equally likely occur average height tree study question consider process constructing tree t inserting order randomly selected n distinct keys initially tree actually values keys matter matters position inserted key n keys 22 process construction view process follows key x keys selected uniformly random inserted tree keys inserted keys greater x right subtree x keys smaller x left subtree height tree constructed plus larger height left subtree height right subtree 23 random variables n number keys x height tree n keys n x y 2 n n want upper bound ey n n cid21 2 n 1 0 1 ey 2emaxfy y g n icid01 ncid0i n x i1 emaxfy y g cid20 ey y icid01 ncid0i icid01 ncid0i cid20 ey ey icid01 ncid0i collecting terms ncid01 4 ey cid20 ey n n x i1 24 analysis 1 n3 claim n cid21 1 ey cid20 n 4cid16 3 cid17 prove induction n 0 base case ey 2 1 1 induction step ncid01 4 ey cid20 ey n n x i1 using fact ncid01 3 n 3 x cid16 3 cid17 cid16 4 cid17 i0 4 1 n 3 ey cid20 cid1 cid1 n cid16 cid17 n 4 4 1 n 3 ey cid20 cid1 n cid16 cid17 4 3 25 jensens inequality function f convex x y x y cid21 0 cid20 cid21 cid20 1 fcid21x 1 cid0 cid21y cid20 cid21fx 1 cid0 cid21fy jensens inequality states random variables x convex function f fex cid20 efx x let x x fx 2 n efx ey n 1 n 3 ex 2 n cid20 cid16 cid17 4 3 3 right hand n 3 taking log sides ex olog n n average height randomly build bst olog n 26",
    "impossible distributed data store simultaneously provide following guarantees consistency read receives recent write error thrown availability request receives non error response guarantee response contains recent write partition tolerance continue operate despite arbitrary network issues 19 cap theorem database view consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 20 cap theorem database view consistency availability responds latest data request gets response able deal network issues consistency partition tolerance responds data distributed store latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 21 cap reality really saying limit number faults requests directed server insist serving request possibly consistent interpreted consistency availability tolerance failure 22 23",
    "ds 4300 introduction graph data model mark fontenot phd northeastern university material referenced graph algorithms practical examples apache spark neo4j needham hodler oreilly press 2019 graph database data model based graph data structure composed nodes edges edges connect nodes uniquely identified contain properties occupation supports queries based graph oriented operations traversals shortest path lots 2 graphs social networks yes things like instagram modeling social interactions fields like psychology sociology web just big graph pages nodes connected hyperlinks edges chemical biological data systems biology genetics interaction relationships chemistry 3 basics graphs graph theory 4 graph labeled property graph composed set node vertex objects relationship edge objects labels used mark node group properties attributes think kv pairs exist nodes relationships nodes associated relationships ok edges connected nodes permitted 5 example 2 labels person car 4 relationship types drives owns lives married properties 6 paths path ordered sequence nodes connected edges nodes edges repeated 3 1 2 ex 1 2 6 5 path 4 6 5 1 2 6 2 3 7 flavors graphs connected vs disconnected path nodes graph weighted vs unweighted edge weight property important algorithms directed vs undirected relationships edges define start end node acyclic vs cyclic graph contains cycles 8 connected vs disconnected 9 weighted vs unweighted 10 directed vs undirected 11 cyclic vs acyclic 12 sparse vs dense 13 trees 14 types graph algorithms pathfinding pathfinding finding shortest path nodes exists probably common operation shortest means fewest edges lowest weight average shortest path used monitor efficiency resiliency networks minimum spanning tree cycle detection maxmin flow types pathfinding 15 bfs vs dfs 16 shortest path 17 types graph algorithms centrality community detection centrality determining nodes important network compared nodes ex social network influencers community detection evaluate clustering partitioning nodes graph tendency strengthen break apart 18 centrality 19 famous graph algorithms dijkstras algorithm single source shortest path algo positively weighted graphs algorithm similar dijkstras added feature using heuristic guide traversal pagerank measures importance node graph based number incoming relationships importance nodes incoming relationships 20 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 21 22",
    "database called data structure store primarily kv store used models graph spatial text search vector time series db enginescom ranking kv stores 18 redis considered memory database supports durability data essentially saving snapshots disk specific intervals b append file journal changes used roll forward failure originally developed 2009 c fast 100000 set ops second rich collection commands does handle complex data secondary indexes supports lookup key 19 redis data types keys usually strings binary sequence values strings lists linked lists sets unique unsorted string elements sorted sets hashes string string geospatial data 20 setting redis docker docker desktop search redis pullrun latest image optional settings add 6379 ports expose port connect normally expose redis port security reasons did prod environment major security hole notice didnt set password 21 connecting datagrip file new data source redis data source make sure port 6379 test connection 22 redis database interaction redis provides 16 databases default numbered 0 15 associated direct interaction redis set commands related setting getting kv pairs variations language libraries available 23 foundation data type string sequence bytes text serialized objects bin arrays simplest data type maps string string use cases caching frequently accessed htmlcssjs fragments config settings user settings info token management counting web pageapp screen views rate limiting 24 initial basic commands set pathtoresource 0 set user1 john doe pathtoresource exists user1 del user1 keys user select 5 select different database 25 basic commands set somevalue 0 incr somevalue increment 1 incrby somevalue 10 increment 10 decr somevalue decrement 1 decrby somevalue 5 decrement 5 incr parses value int increments adds value setnx key value sets value key key does exist 26 hash type value kv entry collection field value pairs use cases used represent basic objectsstructures number fieldvalue pairs hash 232 1 practical limit available resources memory session information management userevent tracking include ttl active session tracking sessions hash key 27 hash commands hset bike1 model demios brand ergonom price 1971 hget bike1 model hget bike1 price hgetall bike1 hmget bike1 model price weight returned hincrby bike1 price 100 28 list type value kv pair linked lists string values use cases implementation stacks queues queue management message passing queues producerconsumer model logging systems easy chronological order build social media streamsfeeds message history chat application batch processing queueing set tasks executed sequentially later time 29 linked lists crash course 10 nil sequential data structure linked nodes instead contiguously allocated memory node points element list points nilnull o1 insert new value insert new value end 30 list commands queue queue like ops lpush bikesrepairs bike1 lpush bikesrepairs bike2 rpop bikesrepairs rpop bilesrepairs 31 list commands stack stack like ops lpush bikesrepairs bike1 lpush bikesrepairs bike2 lpop bikesrepairs lpop bilesrepairs 32 list commands lpush mylist lpush mylist list ops lpush mylist llen mylist lrange key start stop lrange mylist 0 3 lrange mylist 0 0 lrange mylist 2 1 33 json type support json standard uses jsonpath syntax parsingnavigating json document internally stored binary tree structure fast access sub elements 34 set type unordered collection unique strings members use cases track unique items ip addresses visiting site page screen primitive relation set students ds4300 access control lists users permission structures social network friends lists andor group membership supports set operations 35 set commands sadd ds4300 mark sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam sismember ds4300 mark sismember ds4300 nick scard ds4300 36 sadd ds4300 mark set commands sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam scard ds4300 sinter ds4300 cs3200 sdiff ds4300 cs3200 srem ds4300 mark srandmember ds4300 37 38"
  ],
  "config": {
    "chunk_size": 1000,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0074,
    "llm_response_time_sec": 17.406,
    "memory_before_MB": 13.71,
    "memory_after_MB": 15.09
  }
}
{
  "question": "What is the difference between a list where memory is contiguously allocated and a list where linked structures are used?",
  "llm_response": "In a list where memory is contiguously allocated, elements are stored in consecutive blocks of memory. This type of list provides constant time access to any element because each element's position is known, making it efficient for random access. However, insertions or deletions can be less efficient since all subsequent elements must be shifted to make room for the new item or close the gap created by a deletion.\n\nIn contrast, a list where linked structures are used has nodes that contain data and pointers to the next and sometimes the previous node in the list. Insertions and deletions can be done more efficiently since only the pointers need to be updated instead of shifting all subsequent elements as in contiguous allocation. However, random access may not be as efficient because you have to traverse the linked structure to find the desired element, which takes O(n) time on average.",
  "context": [
    "sequence writes happens certain order reading writes appear order 24 25",
    "chapter 12 binary search trees binary search tree binary tree special property called bst property given follows nodes x y y belongs left subtree x key y key x y belongs right subtree x key y greater key x assume keys bst pairwise distinct node following attributes cid15 p left right pointers parent left child right child respectively cid15 key key stored node 1 example 7 4 12 2 6 9 19 3 5 8 11 15 20 2 traversal nodes bst traversal mean visiting nodes graph traversal strategies specicid12ed ordering objects visit current node left subtree right subtree assume left subtree comes right subtree strategies 1 inorder ordering left subtree current node right subtree 2 preorder ordering current node left subtree right subtree 3 postorder ordering left subtree right subtree current node 3 inorder traversal pseudocode recursive algorithm takes input pointer tree executed inorder traversal tree doing traversal prints key node visited inorder walk x nil 1 x return inorder walk 2 leftx 3 print keyx inorder walk 4 rightx write similar pseudocode preorder postorder 4 2 1 3 1 3 2 3 1 2 inorder preorder postorder 7 4 12 2 6 9 19 3 5 8 11 15 20 outcome inorder traversal bst postorder traversal preorder traversal 5 inorder traversal gives 2 3 4 5 6 7 8 9 11 12 15 19 20 preorder traversal gives 7 4 2 3 6 5 12 9 8 11 19 15 20 postorder traversal gives 3 2 5 6 4 8 11 9 15 20 19 12 7 inorder travel bst cid12nds keys nondecreasing order 6 operations bst 1 searching key assume key subtree key searched given input advantage bst property suppose node node key searched search key current node strictly smaller key searched strictly greater key searched case bst property keys th left subtree strictly key searched means need search left subtree examine right subtree case symmetry examine right subtree 7 algorithm k key searched x start node bst search x k 1 y x nil 2 y 6 3 keyy k return y 4 keyy k y righty 5 y lefty 6 return 8 example 7 search 8 4 11 2 6 9 13 nil running time search 9 2 maximum minimum cid12nd minimum identify leftmost node farthest node reach following left branches cid12nd maximum identify rightmost node farthest node reach following right branches bst minimum x nil 1 x return tree 2 y x nil 3 lefty 6 y lefty 4 return keyy bst maximum x nil 1 x return tree 2 y x nil 3 righty 6 y righty 4 return keyy 10 3 insertion suppose need insert node z k keyz using binary search cid12nd nil replacing z does break bst property 11 bst insert x z k nil 1 x return error 2 y x true 3 f 4 keyy k 5 z lefty 6 z righty nil 7 z break 8 g 9 keyy k lefty z 10 rightpy z 12 4 successor predecessor successor respectively predecessor key k search tree smallest respectively largest key belongs tree strictly greater respectively k idea cid12nding successor given node x cid15 x right child successor minimum right subtree x cid15 successor parent farthest node reached x following right branches backward 13 example 23 25 7 4 12 2 6 9 19 3 5 8 11 15 20 14 algorithm bst successor x nil 1 rightx 6 2 f y rightx nil 3 lefty 6 y lefty 4 return y g 5 6 f y x 7 rightpx x y px nil 8 px 6 return px 9 return successor g 15 predecessor similarly",
    "assumes conflicts occur uses locks optimistic concurrency locks assumes conflicts rare uses timestamps version numbers good read heavy systems efficient high conflict systems base alternative acid distributed systems basically available works time soft state state change input eventual consistency eventually reach consistency 8 key value databases design principles simplicity extremely simple data model compared rdbms speed memory o1 retrieval operations scalability easy horizontal scaling eventual consistency use cases data science experiment results storage feature storage model monitoring software engineering session information user profiles shopping carts caching 9 redis key value database open source memory database high performance 100000 set opssecond supports data durability snapshots append journals simple lookup key secondary indexes data types strings basic textbinary data lists linked lists queuesstacks sets unique unordered string collections hashes field value collections sorted sets sets scores ordering specialized types geospatial data json common operations basic crud set exists del atomic counters incr incrby decr decrby list operations lpush rpush lpop rpop llen lrange set operations sadd scard sismember sinter sdiff hash operations hset hget hgetall",
    "ds 4300 redis python mark fontenot phd northeastern university redis py redis py standard client python maintained redis company github repo redisredis py 4300 conda environment pip install redis 2 connecting server import redis redis client redisredishostlocalhost port6379 db2 decode responsestrue docker deployment host localhost 127001 port port mapping given created container probably default 6379 db database 0 15 want connect decode responses data comes server bytes setting true converter decodes strings 3 redis command list list use filter command particular data structure youre targeting list hash set redispy documentation slides meant exhaustive list commands highlights check documentation complete list 4 string commands r represents redis client object rsetclickcountabc 0 val rgetclickcountabc rincrclickcountabc ret val rgetclickcountabc printfclick count ret val 5 string commands 2 r represents redis client object redis clientmsetkey1 val1 key2 val2 key3 val3 printredis clientmgetkey1 key2 key3 returns list val1 val2 val3 6 string commands 3 set mset setex msetnx setnx mget getex getdel incr decr incrby decrby strlen append 7 list commands 1 create list key names values mark sam nick redis clientrpushnames mark sam nick prints mark sam nick printredis clientlrangenames 0 1 8 list commands 2 lpush lpop lset lrem rpush rpop lrange llen lpos commands include moving elements lists popping multiple lists time 9 hash commands 1 redis clienthsetuser session123 mappingfirst sam uelle company redis age 30 prints sam surname uelle company redis age 30 printredis clienthgetalluser session123 10 hash commands 2 hset hget hgetall hkeys hdel hexists hlen hstrlen 11 redis pipelines helps avoid multiple related calls server network overhead r redisredisdecode responsestrue pipe rpipeline range5 pipesetfseati fi set 5 result pipeexecute printset 5 result true true true true true pipe rpipeline chain pipeline commands 3 result pipegetseat0getseat3getseat4execute printget 3 result 0 3 4 12 redis context 13 redis ml simplified example source httpswwwfeatureformcompostfeature stores explained common architectures 14 redis dsml source httpsmadewithmlcomcoursesmlopsfeature store 15",
    "ds 4300 nosql kv dbs mark fontenot phd northeastern university material used permission dr rachlin thanks distributed dbs acid pessimistic concurrency acid transactions focuses data safety considered pessimistic concurrency model assumes transaction protect transactions iow assumes wrong conflicts prevented locking resources transaction complete read write locks write lock analogy borrowing book library httpswwwfreecodecamporgnewshow databases guarantee isolation deeper dive 2 optimistic concurrency transactions obtain locks data read write optimistic assumes conflicts unlikely occur conflict ok add update timestamp version number columns table read changing check end transaction transaction caused modified 3 optimistic concurrency low conflict systems backups analytical dbs read heavy systems conflicts arise handled rolling running transaction notices conflict optimistic concurrency works allows higher concurrency high conflict systems rolling rerunning transactions encounter conflict efficient locking scheme pessimistic model preferable 4 nosql nosql used 1998 carlo strozzi relational database did use sql common modern meaning sql thought non relational dbs idea originally developed response processing unstructured web based data httpswwwdataversityneta brief history non relational databases 5 cap theorem review 2 3 following consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 6 cap theorem review consistency availability responds latest data request gets response able deal network partitions consistency partition tolerance responds data distrib latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 7 acid alternative distrib systems base basically available guarantees availability data cap response failureunreliable data inconsistent changing state appears work time 8 acid alternative distrib systems base soft state state change time wo input changes result eventual consistency data stores dont write consistent replicas dont mutually consistent 9 acid alternative distrib systems base eventual consistency eventually consistent writes eventually stop nodesreplicas updated 10 categories nosql dbs review 11 key value databases 12 key value stores key value key value stores designed simplicity data model extremely simple comparatively tables rdbms complex lends simple crud ops api creation 13 key value stores key value key value stores designed speed usually deployed memory db retrieving value given key typically o1 op bc hash tables similar data structs used hood concept complex queries joins slow things 14 key value stores key value key value stores designed scalability horizontal scaling simple add nodes typically concerned eventual consistency meaning distributed environment guarantee nodes eventually converge value 15 kv ds use cases edaexperimentation results store store intermediate results data preprocessing eda store experiment testing ab results wo prod db feature store store frequently accessed feature low latency retrieval model training prediction model monitoring store key metrics performance model example real time inferencing 16 kv swe use cases storing session information current session stored single post retrieved single fast user profiles preferences user info obtained single operation language tz product ui preferences shopping cart data cart data tied user needs available browsers machines sessions caching layer disk based database 17 redis db redis remote directory server open source memory database called data structure store primarily kv store used models graph spatial text search vector time series db enginescom ranking kv stores 18 redis considered memory database supports durability data essentially saving snapshots disk specific intervals b append file journal changes used roll forward failure originally developed 2009 c fast 100000 set ops second rich",
    "impossible distributed data store simultaneously provide following guarantees consistency read receives recent write error thrown availability request receives non error response guarantee response contains recent write partition tolerance continue operate despite arbitrary network issues 19 cap theorem database view consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 20 cap theorem database view consistency availability responds latest data request gets response able deal network issues consistency partition tolerance responds data distributed store latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 21 cap reality really saying limit number faults requests directed server insist serving request possibly consistent interpreted consistency availability tolerance failure 22 23",
    "general trade offs exist consistency availability performance indexing strategies significantly impact query performance nosql databases great unstructured data sacrifice strong consistency graph databases optimized relationships large scale storage retrieval foundations foundations large scale storage retrieval introduction information storage information retrieval ir process storing organizing retrieving data efficiently ir systems range search engines google databases storing medical records key challenges scalability handling petabytes data efficiency fast retrieval times google milliseconds consistency availability ensuring fault tolerance reliability searching strategies linear search simple inefficient time complexity binary search works sorted data olog n complexity indexing key making search efficient uses external data structures like b trees hash indexes indexing techniques hash indexing best unique lookups o1 average case b trees b trees used databases optimized disk access inverted index used search engines maps words documents record collection values attribues single entity instance row table collection set records entity type table trvially stored sequuential order like list search key value attribute entity type 1 attribute nx bytes memory record takes x bytes memory n records need contiguously allocated list nx byte allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses arrays faster random access inserting end slow linked lists faster inserting list random access slow linear search best case 1 worst case binary search best case 1 worst case log2n read code explain binary search isdoes binary search tree binary tree node left subtree parent node right parent avl tree approx balanced binary search tree maintains balance faster avl property hlst hrst 1 self balancing inserting imbalance ll lr rl rr trees b trees indexing b trees used database indexing filesystems ntfs postgresql indexes keeps tree height small reducing disk reads b trees vs b trees b trees store keys values internal leaf nodes b trees store values leaf nodes making range queries efficient bst properties left subtree values root right subtree values search time complexity olog n balanced unbalanced avl trees self balancing bst ensures olog n search time rotations used rebalancing ll rotation single right rotation rr rotation single left rotation lr rotation left right rotation rl rotation right left rotation sql vs sql sql structured query langage relational easy querying relationships data multiple datas acid compliant atomicity consistency isolation durability good storing querying unstructured data format unknown difficult scale horizontally nosql document keyvalue graph wide column stores flexible simpler set shard data different data stores allowing distributed databases making horizontal scaling easier large data stored designed distributed purposes optimistic concurrency assumes conflicts unlikely occur add updated timestamp version number columns table modified independently transactions relational databases vs nosql acid vs base acid ensures strong consistency atomicity transactions consistency data remains valid isolation transactions interfere durability committed stays committed base prioritizes availability consistency basically available soft state eventually consistent sql vs nosql feature sql relational nosql non relational schema fixed structured flexible dynamic scalability vertical scale horizontal scale consistency strong acid compliance eventual consistency examples mysql postgresql mongodb cassandra neo4j nosql cap theorem consistency nodes data simultaneously availability request gets response stale partition tolerance functions despite network failures nosql categories type example use case key value redis caching real time stores dynamodb analytics document mongodb json like flexible data stores couchdb models column stores apache time series analytics cassandra graph neo4j relationship heavy data databases graph data models neo4j graph theory basics nodes entities users products edges relationships nodes traversal algorithms bfs dfs dijkstras shortest path neo4j cypher neo4j acid compliant graph database cypher query examples match friend b return b data replication distributed systems improves fault tolerance node crashes serve data enables load balancing distribute requests multiple servers replication strategies master slave replication node handles writes replicate reads multi master replication multiple nodes accept writes requires conflict resolution eventual consistency updates propagate time used nosql systems like dynamodb",
    "ds 4300 large scale information storage retrieval foundations mark fontenot phd northeastern university searching searching common operation performed database sql select statement arguably versatile complex baseline efficiency linear search start beginning list proceed element element youre looking element havent 2 searching record collection values attributes single entity instance row table collection set records entity type table trivially stored sequential order like list search key value attribute entity type 1 attribute 3 lists records record takes x bytes memory n records need nx bytes memory contiguously allocated list nx bytes allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses 4 contiguous vs linked 6 records contiguously allocated array extra storage memory address 6 records linked memory addresses linked list 5 pros cons arrays faster random access slow inserting end records insert 2nd record records 5 records moved make space linked lists faster inserting list slower random access insert 2nd record 6 observations arrays fast random access slow random insertions linked lists slow random access fast random insertions 7 binary search input array values sorted order target value output location index target located value indicating target def binary searcharr target left right 0 lenarr 1 left right left right c g m p r z target mid left right 2 arrmid target mid return mid target arrmid reset right mid 1 left right elif arrmid target left mid 1 c g m p r z target mid right mid 1 return 1 8 time complexity linear search best case target element 1 comparison worst case target array n comparisons worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog n time 2 complexity 9 database searching assume data stored disk column ids value searching specific id fast want search specific specialval option linear scan column store data disk sorted id specialval time data duplicated space inefficient 10 database searching assume data stored disk column ids value searching specific id fast want search specific need external data structure specialval support faster searching option linear scan column specialval linear scan store data disk sorted id specialval time data duplicated space inefficient 11 arsenal 1 array tuples specialval rownumber sorted specialval use binary search quickly locate particular specialval corresponding row table b insert table like inserting sorted array slow 2 linked list tuples specialval rownumber sorted specialval searching specialval slow linear scan required b inserting table theoretically quick add list 12 fast insert fast search binary search tree binary tree node left subtree parent node right subtree greater parent image httpscoursesgraingerillinoiseducs225sp2019notesbst 13 board 14",
    "ds 4300 neo4j mark fontenot phd northeastern university material referenced graph algorithms practical examples apache spark neo4j needham hodler oreilly press 2019 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 2 neo4j query language plugins cypher neo4js graph query language created 2011 goal sql equivalent language graph databases provides visual way matching patterns relationships nodes connect othernodes apoc plugin awesome procedures cypher add library provides hundreds procedures functions graph data science plugin provides efficient implementations common graph algorithms like ones talked yesterday 3 neo4j docker compose 4 docker compose supports multi container management set declarative using yaml docker composeyaml file services volumes networks 1 command used start stop scale number services time provides consistent method producing identical environment works machine interaction command line 5 docker composeyaml services secrets neo4j container neo4j docker compose file use env image neo4jlatest ports files 74747474 76877687 environment neo4j authneo4jneo4j password neo4j apoc export file enabledtrue neo4j apoc import file enabledtrue neo4j apoc import file use neo4j configtrue neo4j pluginsapoc graph data science volumes neo4j dbdatadata neo4j dblogslogs neo4j dbimportvarlibneo4jimport neo4j dbpluginsplugins 6 env files env files stores collection environment variables good way environment variables different platforms separate envlocal env file envdev envprod neo4j passwordabc123 7 docker compose commands test docker cli properly installed run docker version major docker commands docker compose docker compose d docker compose docker compose start docker compose stop docker compose build docker compose build cache 8 localhost7474 9 neo4j browser localhost7474 login httpsneo4jcomdocsbrowser manualcurrentvisual tour 10 inserting data creating nodes create user alice birthplace paris create user bob birthplace london create user carol birthplace london create user dave birthplace london create user eve birthplace rome 11 adding edge variable names create user alice birthplace paris create user bob birthplace london match aliceuser namealice match bobuser bob create alice knows 2022 12 01 bob note relationships directed neo4j 12 matching users born london match usruser birthplace london return usrname usrbirthplace 13 download dataset import folder clone repo httpsgithubcompacktpublishinggraph data science neo4j chapter02data data repo unzip netflixzip file copy netflix titlescsv following folder docker compose file neo4j dbneo4j dbimport 14 importing data 15 basic data importing type following cypher editor neo4j browser load csv headers filenetflix titlescsv line createmovie id lineshow id title linetitle releaseyear linerelease year 16 loading csvs general syntax load csv headers filefile import foldercsv line fieldterminator stuffs line 17 importing directors time load csv headers filenetflix titlescsv line splitlinedirector directors list unwind directors list director create person trimdirector generates duplicate person nodes director direct 1 movie 18 importing directors merged match pperson delete p load csv headers filenetflix titlescsv line splitlinedirector directors list unwind directors list director merge person director 19 adding edges load csv headers filenetflix titlescsv line match mmovie id lineshow id m splitlinedirector directors list unwind directors list director match pperson director create p directed m 20 gut check lets check movie titled ray match mmovie title ray directed pperson return m p 21 22",
    "random variables x convex function f fex cid20 efx x let x x fx 2 n efx ey n 1 n 3 ex 2 n cid20 cid16 cid17 4 3 3 right hand n 3 taking log sides ex olog n n average height randomly build bst olog n 26"
  ],
  "config": {
    "chunk_size": 1000,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0071,
    "llm_response_time_sec": 15.4664,
    "memory_before_MB": 12.79,
    "memory_after_MB": 14.29
  }
}
{
  "question": "When was Redis originally released?",
  "llm_response": "Redis, a popular open-source in-memory data structure store, was first released on January 10, 2011.",
  "context": [
    "sequence writes happens certain order reading writes appear order 24 25",
    "impossible distributed data store simultaneously provide following guarantees consistency read receives recent write error thrown availability request receives non error response guarantee response contains recent write partition tolerance continue operate despite arbitrary network issues 19 cap theorem database view consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 20 cap theorem database view consistency availability responds latest data request gets response able deal network issues consistency partition tolerance responds data distributed store latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 21 cap reality really saying limit number faults requests directed server insist serving request possibly consistent interpreted consistency availability tolerance failure 22 23",
    "random variables x convex function f fex cid20 efx x let x x fx 2 n efx ey n 1 n 3 ex 2 n cid20 cid16 cid17 4 3 3 right hand n 3 taking log sides ex olog n n average height randomly build bst olog n 26",
    "ds 4300 nosql kv dbs mark fontenot phd northeastern university material used permission dr rachlin thanks distributed dbs acid pessimistic concurrency acid transactions focuses data safety considered pessimistic concurrency model assumes transaction protect transactions iow assumes wrong conflicts prevented locking resources transaction complete read write locks write lock analogy borrowing book library httpswwwfreecodecamporgnewshow databases guarantee isolation deeper dive 2 optimistic concurrency transactions obtain locks data read write optimistic assumes conflicts unlikely occur conflict ok add update timestamp version number columns table read changing check end transaction transaction caused modified 3 optimistic concurrency low conflict systems backups analytical dbs read heavy systems conflicts arise handled rolling running transaction notices conflict optimistic concurrency works allows higher concurrency high conflict systems rolling rerunning transactions encounter conflict efficient locking scheme pessimistic model preferable 4 nosql nosql used 1998 carlo strozzi relational database did use sql common modern meaning sql thought non relational dbs idea originally developed response processing unstructured web based data httpswwwdataversityneta brief history non relational databases 5 cap theorem review 2 3 following consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 6 cap theorem review consistency availability responds latest data request gets response able deal network partitions consistency partition tolerance responds data distrib latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 7 acid alternative distrib systems base basically available guarantees availability data cap response failureunreliable data inconsistent changing state appears work time 8 acid alternative distrib systems base soft state state change time wo input changes result eventual consistency data stores dont write consistent replicas dont mutually consistent 9 acid alternative distrib systems base eventual consistency eventually consistent writes eventually stop nodesreplicas updated 10 categories nosql dbs review 11 key value databases 12 key value stores key value key value stores designed simplicity data model extremely simple comparatively tables rdbms complex lends simple crud ops api creation 13 key value stores key value key value stores designed speed usually deployed memory db retrieving value given key typically o1 op bc hash tables similar data structs used hood concept complex queries joins slow things 14 key value stores key value key value stores designed scalability horizontal scaling simple add nodes typically concerned eventual consistency meaning distributed environment guarantee nodes eventually converge value 15 kv ds use cases edaexperimentation results store store intermediate results data preprocessing eda store experiment testing ab results wo prod db feature store store frequently accessed feature low latency retrieval model training prediction model monitoring store key metrics performance model example real time inferencing 16 kv swe use cases storing session information current session stored single post retrieved single fast user profiles preferences user info obtained single operation language tz product ui preferences shopping cart data cart data tied user needs available browsers machines sessions caching layer disk based database 17 redis db redis remote directory server open source memory database called data structure store primarily kv store used models graph spatial text search vector time series db enginescom ranking kv stores 18 redis considered memory database supports durability data essentially saving snapshots disk specific intervals b append file journal changes used roll forward failure originally developed 2009 c fast 100000 set ops second rich",
    "ds 4300 introduction graph data model mark fontenot phd northeastern university material referenced graph algorithms practical examples apache spark neo4j needham hodler oreilly press 2019 graph database data model based graph data structure composed nodes edges edges connect nodes uniquely identified contain properties occupation supports queries based graph oriented operations traversals shortest path lots 2 graphs social networks yes things like instagram modeling social interactions fields like psychology sociology web just big graph pages nodes connected hyperlinks edges chemical biological data systems biology genetics interaction relationships chemistry 3 basics graphs graph theory 4 graph labeled property graph composed set node vertex objects relationship edge objects labels used mark node group properties attributes think kv pairs exist nodes relationships nodes associated relationships ok edges connected nodes permitted 5 example 2 labels person car 4 relationship types drives owns lives married properties 6 paths path ordered sequence nodes connected edges nodes edges repeated 3 1 2 ex 1 2 6 5 path 4 6 5 1 2 6 2 3 7 flavors graphs connected vs disconnected path nodes graph weighted vs unweighted edge weight property important algorithms directed vs undirected relationships edges define start end node acyclic vs cyclic graph contains cycles 8 connected vs disconnected 9 weighted vs unweighted 10 directed vs undirected 11 cyclic vs acyclic 12 sparse vs dense 13 trees 14 types graph algorithms pathfinding pathfinding finding shortest path nodes exists probably common operation shortest means fewest edges lowest weight average shortest path used monitor efficiency resiliency networks minimum spanning tree cycle detection maxmin flow types pathfinding 15 bfs vs dfs 16 shortest path 17 types graph algorithms centrality community detection centrality determining nodes important network compared nodes ex social network influencers community detection evaluate clustering partitioning nodes graph tendency strengthen break apart 18 centrality 19 famous graph algorithms dijkstras algorithm single source shortest path algo positively weighted graphs algorithm similar dijkstras added feature using heuristic guide traversal pagerank measures importance node graph based number incoming relationships importance nodes incoming relationships 20 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 21 22",
    "ds 4300 large scale information storage retrieval mark fontenot phd northeastern university hi mark fontenot phd office 353 meserve hall office hours m th 130 300 pm times dont work just dm slack set alternate time usually available slack just dm mfontenotnortheasternedu 2 teaching assistants iker acosta venegas dallon archibald nathan cheung aryan jain sevinch noori abhishek kumar eddy liu junxiang lin 3 course materials notes assignments httpsmarkfontenotnetteachingds430025s ds4300 assignment submissions grades gradescope q platform campuswire quick dms announcements slack 4 whats class end class understand efficiency related concepts including limitations rdbmss understand data replication distribution effects typical db usage scenarios understand use cases data models various nosql database systems including storing retrieving data data models include document based key value stores graph based access implement data engineering big data related aws services 5 course deliverables evaluation 6 assignments homeworks practicals usually tuesday nights 1159 unless stated 3 bonus submitting 48 hours early 3 submitting 48 hours early late submissions accepted life happens gets 1 free questions asked 48 hour extension dm dr fontenot slack original deadline requesting use extension 7 assignments submissions gradescope andor github unless directed submit pdfs unless instructed submitting pdf sure associate questions gradescope correct page pdf failure result grade 0 assignment regrade requests submitted 48 hours grades released gradescope exceptions 8 midterm monday march 17 mark calendars 9 final grade breakdown homeworks 5 30 practicals 2 20 midterm 20 semester project 30 10 reference materials primary resources books playlist add additional materials playlist webpage semester progresses oreilly playlist 11 tentative list topics thinking data storage retrieval data structures level far relational model nosql databases document databases mongo graph databases neo4j keyvalue databases maybe vector databases data distribution replication distributed sql dbs apache sparksparksql big data tools services aws 12 tools need install laptop docker desktop anaconda miniconda python youre welcome use distro youre responsible fixing doesnt work dependency conflicts database access tool like datagrip dbeaver vs code set python development info vscode python anaconda ability interact git github terminal gui app 13 topics review days shellcmd promptpowershell cli windows want unix terminal wsl2 zsh windows navigating file running commands like pip conda python command line args docker docker compose basics dockerfiles docker composeyaml files port mapping setting volumes mapping host guest os 14 python rusty havent ton python crash course net ninja yt oreilly python section class playlist python object oriented programming video course simon sez e matthes python crash course 3rd edition starch press related yt video playlist listed 15 expectations conduct respectfully dont distract classmates learning dont cheat work unless group assignment discussing problems encouraged formulate solutions syllabus details 16 lets gooo 17",
    "chapter 12 binary search trees binary search tree binary tree special property called bst property given follows nodes x y y belongs left subtree x key y key x y belongs right subtree x key y greater key x assume keys bst pairwise distinct node following attributes cid15 p left right pointers parent left child right child respectively cid15 key key stored node 1 example 7 4 12 2 6 9 19 3 5 8 11 15 20 2 traversal nodes bst traversal mean visiting nodes graph traversal strategies specicid12ed ordering objects visit current node left subtree right subtree assume left subtree comes right subtree strategies 1 inorder ordering left subtree current node right subtree 2 preorder ordering current node left subtree right subtree 3 postorder ordering left subtree right subtree current node 3 inorder traversal pseudocode recursive algorithm takes input pointer tree executed inorder traversal tree doing traversal prints key node visited inorder walk x nil 1 x return inorder walk 2 leftx 3 print keyx inorder walk 4 rightx write similar pseudocode preorder postorder 4 2 1 3 1 3 2 3 1 2 inorder preorder postorder 7 4 12 2 6 9 19 3 5 8 11 15 20 outcome inorder traversal bst postorder traversal preorder traversal 5 inorder traversal gives 2 3 4 5 6 7 8 9 11 12 15 19 20 preorder traversal gives 7 4 2 3 6 5 12 9 8 11 19 15 20 postorder traversal gives 3 2 5 6 4 8 11 9 15 20 19 12 7 inorder travel bst cid12nds keys nondecreasing order 6 operations bst 1 searching key assume key subtree key searched given input advantage bst property suppose node node key searched search key current node strictly smaller key searched strictly greater key searched case bst property keys th left subtree strictly key searched means need search left subtree examine right subtree case symmetry examine right subtree 7 algorithm k key searched x start node bst search x k 1 y x nil 2 y 6 3 keyy k return y 4 keyy k y righty 5 y lefty 6 return 8 example 7 search 8 4 11 2 6 9 13 nil running time search 9 2 maximum minimum cid12nd minimum identify leftmost node farthest node reach following left branches cid12nd maximum identify rightmost node farthest node reach following right branches bst minimum x nil 1 x return tree 2 y x nil 3 lefty 6 y lefty 4 return keyy bst maximum x nil 1 x return tree 2 y x nil 3 righty 6 y righty 4 return keyy 10 3 insertion suppose need insert node z k keyz using binary search cid12nd nil replacing z does break bst property 11 bst insert x z k nil 1 x return error 2 y x true 3 f 4 keyy k 5 z lefty 6 z righty nil 7 z break 8 g 9 keyy k lefty z 10 rightpy z 12 4 successor predecessor successor respectively predecessor key k search tree smallest respectively largest key belongs tree strictly greater respectively k idea cid12nding successor given node x cid15 x right child successor minimum right subtree x cid15 successor parent farthest node reached x following right branches backward 13 example 23 25 7 4 12 2 6 9 19 3 5 8 11 15 20 14 algorithm bst successor x nil 1 rightx 6 2 f y rightx nil 3 lefty 6 y lefty 4 return y g 5 6 f y x 7 rightpx x y px nil 8 px 6 return px 9 return successor g 15 predecessor similarly",
    "general trade offs exist consistency availability performance indexing strategies significantly impact query performance nosql databases great unstructured data sacrifice strong consistency graph databases optimized relationships large scale storage retrieval foundations foundations large scale storage retrieval introduction information storage information retrieval ir process storing organizing retrieving data efficiently ir systems range search engines google databases storing medical records key challenges scalability handling petabytes data efficiency fast retrieval times google milliseconds consistency availability ensuring fault tolerance reliability searching strategies linear search simple inefficient time complexity binary search works sorted data olog n complexity indexing key making search efficient uses external data structures like b trees hash indexes indexing techniques hash indexing best unique lookups o1 average case b trees b trees used databases optimized disk access inverted index used search engines maps words documents record collection values attribues single entity instance row table collection set records entity type table trvially stored sequuential order like list search key value attribute entity type 1 attribute nx bytes memory record takes x bytes memory n records need contiguously allocated list nx byte allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses arrays faster random access inserting end slow linked lists faster inserting list random access slow linear search best case 1 worst case binary search best case 1 worst case log2n read code explain binary search isdoes binary search tree binary tree node left subtree parent node right parent avl tree approx balanced binary search tree maintains balance faster avl property hlst hrst 1 self balancing inserting imbalance ll lr rl rr trees b trees indexing b trees used database indexing filesystems ntfs postgresql indexes keeps tree height small reducing disk reads b trees vs b trees b trees store keys values internal leaf nodes b trees store values leaf nodes making range queries efficient bst properties left subtree values root right subtree values search time complexity olog n balanced unbalanced avl trees self balancing bst ensures olog n search time rotations used rebalancing ll rotation single right rotation rr rotation single left rotation lr rotation left right rotation rl rotation right left rotation sql vs sql sql structured query langage relational easy querying relationships data multiple datas acid compliant atomicity consistency isolation durability good storing querying unstructured data format unknown difficult scale horizontally nosql document keyvalue graph wide column stores flexible simpler set shard data different data stores allowing distributed databases making horizontal scaling easier large data stored designed distributed purposes optimistic concurrency assumes conflicts unlikely occur add updated timestamp version number columns table modified independently transactions relational databases vs nosql acid vs base acid ensures strong consistency atomicity transactions consistency data remains valid isolation transactions interfere durability committed stays committed base prioritizes availability consistency basically available soft state eventually consistent sql vs nosql feature sql relational nosql non relational schema fixed structured flexible dynamic scalability vertical scale horizontal scale consistency strong acid compliance eventual consistency examples mysql postgresql mongodb cassandra neo4j nosql cap theorem consistency nodes data simultaneously availability request gets response stale partition tolerance functions despite network failures nosql categories type example use case key value redis caching real time stores dynamodb analytics document mongodb json like flexible data stores couchdb models column stores apache time series analytics cassandra graph neo4j relationship heavy data databases graph data models neo4j graph theory basics nodes entities users products edges relationships nodes traversal algorithms bfs dfs dijkstras shortest path neo4j cypher neo4j acid compliant graph database cypher query examples match friend b return b data replication distributed systems improves fault tolerance node crashes serve data enables load balancing distribute requests multiple servers replication strategies master slave replication node handles writes replicate reads multi master replication multiple nodes accept writes requires conflict resolution eventual consistency updates propagate time used nosql systems like dynamodb",
    "drama dbmoviescountdocuments year 2010 awardswins gte 5 genres drama 28 mongosh project return names movies movies collection released 2010 won 5 awards genre drama dbmoviescountdocuments year 2010 awardswins gte 5 genres drama 1 id 0 1 return 0 dont return 29 pymongo 30 pymongo pymongo python library interfacing mongodb instances pymongo import mongoclient client mongoclient mongodbuser namepwlocalhost27017 31 getting database collection pymongo import mongoclient client mongoclient mongodbuser namepwlocalhost27017 db clientds4300 collection dbmycollection 32 inserting single document db clientds4300 collection dbmycollection post author mark text mongodb cool tags mongodb python post id collectioninsert onepostinserted id printpost id 33 count documents collection select count collection demodbcollectioncount documents 34 35",
    "ds 4300 neo4j mark fontenot phd northeastern university material referenced graph algorithms practical examples apache spark neo4j needham hodler oreilly press 2019 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 2 neo4j query language plugins cypher neo4js graph query language created 2011 goal sql equivalent language graph databases provides visual way matching patterns relationships nodes connect othernodes apoc plugin awesome procedures cypher add library provides hundreds procedures functions graph data science plugin provides efficient implementations common graph algorithms like ones talked yesterday 3 neo4j docker compose 4 docker compose supports multi container management set declarative using yaml docker composeyaml file services volumes networks 1 command used start stop scale number services time provides consistent method producing identical environment works machine interaction command line 5 docker composeyaml services secrets neo4j container neo4j docker compose file use env image neo4jlatest ports files 74747474 76877687 environment neo4j authneo4jneo4j password neo4j apoc export file enabledtrue neo4j apoc import file enabledtrue neo4j apoc import file use neo4j configtrue neo4j pluginsapoc graph data science volumes neo4j dbdatadata neo4j dblogslogs neo4j dbimportvarlibneo4jimport neo4j dbpluginsplugins 6 env files env files stores collection environment variables good way environment variables different platforms separate envlocal env file envdev envprod neo4j passwordabc123 7 docker compose commands test docker cli properly installed run docker version major docker commands docker compose docker compose d docker compose docker compose start docker compose stop docker compose build docker compose build cache 8 localhost7474 9 neo4j browser localhost7474 login httpsneo4jcomdocsbrowser manualcurrentvisual tour 10 inserting data creating nodes create user alice birthplace paris create user bob birthplace london create user carol birthplace london create user dave birthplace london create user eve birthplace rome 11 adding edge variable names create user alice birthplace paris create user bob birthplace london match aliceuser namealice match bobuser bob create alice knows 2022 12 01 bob note relationships directed neo4j 12 matching users born london match usruser birthplace london return usrname usrbirthplace 13 download dataset import folder clone repo httpsgithubcompacktpublishinggraph data science neo4j chapter02data data repo unzip netflixzip file copy netflix titlescsv following folder docker compose file neo4j dbneo4j dbimport 14 importing data 15 basic data importing type following cypher editor neo4j browser load csv headers filenetflix titlescsv line createmovie id lineshow id title linetitle releaseyear linerelease year 16 loading csvs general syntax load csv headers filefile import foldercsv line fieldterminator stuffs line 17 importing directors time load csv headers filenetflix titlescsv line splitlinedirector directors list unwind directors list director create person trimdirector generates duplicate person nodes director direct 1 movie 18 importing directors merged match pperson delete p load csv headers filenetflix titlescsv line splitlinedirector directors list unwind directors list director merge person director 19 adding edges load csv headers filenetflix titlescsv line match mmovie id lineshow id m splitlinedirector directors list unwind directors list director match pperson director create p directed m 20 gut check lets check movie titled ray match mmovie title ray directed pperson return m p 21 22"
  ],
  "config": {
    "chunk_size": 1000,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0097,
    "llm_response_time_sec": 9.3622,
    "memory_before_MB": 12.87,
    "memory_after_MB": 14.39
  }
}
{
  "question": "Succinctly describe the four components of ACID compliant transactions.",
  "llm_response": "The four components of an ACID-compliant transaction are Atomicity, Consistency, Isolation, and Durability:\n\n1. **Atomicity**: Each transaction is treated as a single, indivisible unit of work. All operations within the transaction must either complete successfully or be rolled back if any operation fails.\n\n2. **Consistency**: A transaction ensures that all database constraints are met before and after execution. The system's state remains consistent both during and post-transaction.\n\n3. **Isolation**: Transactions are executed in isolation, ensuring that the changes made by one transaction do not interfere with those of another concurrent transaction.\n\n4. **Durability**: Once a transaction is committed, its effects are permanent, surviving system failures, power outages or other disruptions. The database ensures that all completed transactions are recorded persistently on stable storage.",
  "context": [
    "ds 4300 large scale information storage retrieval foundations mark fontenot phd northeastern university searching searching common operation performed database sql select statement arguably versatile complex baseline efficiency linear search start beginning list proceed element element youre looking element havent 2 searching record collection values attributes single entity instance row table collection set records entity type table trivially stored sequential order like list search key value attribute entity type 1 attribute 3 lists records record takes x bytes memory n records need nx bytes memory contiguously allocated list nx bytes allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses 4 contiguous vs linked 6 records contiguously allocated array extra storage memory address 6 records linked memory addresses linked list 5 pros cons arrays faster random access slow inserting end records insert 2nd record records 5 records moved make space linked lists faster inserting list slower random access insert 2nd record 6 observations arrays fast random access slow random insertions linked lists slow random access fast random insertions 7 binary search input array values sorted order target value output location index target located value indicating target def binary searcharr target left right 0 lenarr 1 left right left right c g m p r z target mid left right 2 arrmid target mid return mid target arrmid reset right mid 1 left right elif arrmid target left mid 1 c g m p r z target mid right mid 1 return 1 8 time complexity linear search best case target element 1 comparison worst case target array n comparisons worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog n time 2 complexity 9 database searching assume data stored disk column ids value searching specific id fast want search specific specialval option linear scan column store data disk sorted id specialval time data duplicated space inefficient 10 database searching assume data stored disk column ids value searching specific id fast want search specific need external data structure specialval support faster searching option linear scan column specialval linear scan store data disk sorted id specialval time data duplicated space inefficient 11 arsenal 1 array tuples specialval rownumber sorted specialval use binary search quickly locate particular specialval corresponding row table b insert table like inserting sorted array slow 2 linked list tuples specialval rownumber sorted specialval searching specialval slow linear scan required b inserting table theoretically quick add list 12 fast insert fast search binary search tree binary tree node left subtree parent node right subtree greater parent image httpscoursesgraingerillinoiseducs225sp2019notesbst 13 board 14",
    "sequence writes happens certain order reading writes appear order 24 25",
    "ds 4300 introduction graph data model mark fontenot phd northeastern university material referenced graph algorithms practical examples apache spark neo4j needham hodler oreilly press 2019 graph database data model based graph data structure composed nodes edges edges connect nodes uniquely identified contain properties occupation supports queries based graph oriented operations traversals shortest path lots 2 graphs social networks yes things like instagram modeling social interactions fields like psychology sociology web just big graph pages nodes connected hyperlinks edges chemical biological data systems biology genetics interaction relationships chemistry 3 basics graphs graph theory 4 graph labeled property graph composed set node vertex objects relationship edge objects labels used mark node group properties attributes think kv pairs exist nodes relationships nodes associated relationships ok edges connected nodes permitted 5 example 2 labels person car 4 relationship types drives owns lives married properties 6 paths path ordered sequence nodes connected edges nodes edges repeated 3 1 2 ex 1 2 6 5 path 4 6 5 1 2 6 2 3 7 flavors graphs connected vs disconnected path nodes graph weighted vs unweighted edge weight property important algorithms directed vs undirected relationships edges define start end node acyclic vs cyclic graph contains cycles 8 connected vs disconnected 9 weighted vs unweighted 10 directed vs undirected 11 cyclic vs acyclic 12 sparse vs dense 13 trees 14 types graph algorithms pathfinding pathfinding finding shortest path nodes exists probably common operation shortest means fewest edges lowest weight average shortest path used monitor efficiency resiliency networks minimum spanning tree cycle detection maxmin flow types pathfinding 15 bfs vs dfs 16 shortest path 17 types graph algorithms centrality community detection centrality determining nodes important network compared nodes ex social network influencers community detection evaluate clustering partitioning nodes graph tendency strengthen break apart 18 centrality 19 famous graph algorithms dijkstras algorithm single source shortest path algo positively weighted graphs algorithm similar dijkstras added feature using heuristic guide traversal pagerank measures importance node graph based number incoming relationships importance nodes incoming relationships 20 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 21 22",
    "ds 4300 document databases mongodb mark fontenot phd northeastern university material used permission dr rachlin thanks document database document database non relational database stores data structured documents usually json designed simple flexible scalable 2 json json javascript object notation lightweight data interchange format easy humans read write easy machines parse generate json built structures collection namevalue pairs various languages operationalized object record struct dictionary hash table keyed list associative array ordered list values languages operationalized array vector list sequence universal data structures supported virtually modern programming languages json makes great data interchange format 3 json syntax httpswwwjsonorgjson enhtml 4 binary json bson bson binary json binary encoded serialization json like document structure supports extended types basic json date binarydata lightweight space overhead minimum traversable designed easily traversed vitally important document db efficient encoding decoding efficient supported modern programming languages 5 xml extensible markup language precursor json data exchange format xml css web pages separated content formatting structurally similar html tag set extensible 6 xml related toolstechnologies xpath syntax retrieving specific elements xml doc xquery query language interrogating xml documents sql xml dtd document type definition language describing allowed structure xml document xslt extensible stylesheet language transformation tool transform xml formats including non xml formats html 7 document databases document databases address impedance mismatch problem object persistence oo systems relational dbs structure data oo programming inheritance composition types save complex object relational database basically deconstruct structure document self describing aligned apps use jsonxml transport layer 8 mongodb 9 mongodb started 2007 doubleclick acquired google 3 veterans realized limitations relational databases serving 400000 ads second mongodb short humongous database mongodb atlas released 2016 documentdb service httpswwwmongodbcomcompanyour story 10 mongodb structure database collection collection b collection c document 1 document 1 document 1 document 2 document 2 document 2 document 3 document 3 document 3 11 mongodb documents predefined schema documents needed document collection different dataschema 12 relational vs mongodocument db rdbms mongodb database database tableview collection row document column field index index join embedded document foreign key reference 13 mongodb features rich query support robust support crud ops indexing supports primary secondary indices document fields replication supports replica sets automatic failover load balancing built 14 mongodb versions mongodb atlas fully managed mongodb service cloud dbaas mongodb enterprise subscription based self managed version mongodb mongodb community source available free use self managed 15 interacting mongodb mongosh mongodb shell cli tool interacting mongodb instance mongodb compass free open source gui work mongodb database datagrip 3rd party tools major language library interface mongodb pymongo python mongoose javascriptnode 16 mongodb community edition docker create container map hostcontainer port 27017 e initial username d password superuser 17 mongodb compass gui tool interacting mongodb instance download install 18 load mflix sample data set compass create new database named mflix download mflix sample dataset unzip import json files users theaters movies comments new collections mflix database 19 creating database collection create new db mflix users create new collection 20 mongosh mongo shell like select collectionfind filters projections 21 mongosh select users use mflix dbusersfind 22 select mongosh users davos seaworth filter dbusersfindname davos seaworth 23 mongosh select movies rated pg pg 13 dbmoviesfindrated pg pg 13 24 mongosh return movies released mexico imdb rating 7 dbmoviesfind countries mexico imdbrating gte 7 25 mongosh return movies movies collection released 2010 won 5 awards genre drama dbmoviesfind year 2010 awardswins gte 5 genres drama 26 comparison operators 27 mongosh countdocuments movies movies collection released 2010 won 5 awards genre drama dbmoviescountdocuments year 2010 awardswins gte 5 genres drama 28 mongosh project return names movies movies collection released 2010 won 5 awards genre drama dbmoviescountdocuments year 2010 awardswins gte 5 genres drama 1 id 0 1 return 0 dont return 29 pymongo 30 pymongo pymongo python library interfacing mongodb instances pymongo import mongoclient client mongoclient mongodbuser namepwlocalhost27017 31 getting database collection pymongo import mongoclient client mongoclient mongodbuser namepwlocalhost27017 db clientds4300 collection",
    "assumes conflicts occur uses locks optimistic concurrency locks assumes conflicts rare uses timestamps version numbers good read heavy systems efficient high conflict systems base alternative acid distributed systems basically available works time soft state state change input eventual consistency eventually reach consistency 8 key value databases design principles simplicity extremely simple data model compared rdbms speed memory o1 retrieval operations scalability easy horizontal scaling eventual consistency use cases data science experiment results storage feature storage model monitoring software engineering session information user profiles shopping carts caching 9 redis key value database open source memory database high performance 100000 set opssecond supports data durability snapshots append journals simple lookup key secondary indexes data types strings basic textbinary data lists linked lists queuesstacks sets unique unordered string collections hashes field value collections sorted sets sets scores ordering specialized types geospatial data json common operations basic crud set exists del atomic counters incr incrby decr decrby list operations lpush rpush lpop rpop llen lrange set operations sadd scard sismember sinter sdiff hash operations hset hget hgetall",
    "ds 4300 large scale information storage retrieval mark fontenot phd northeastern university hi mark fontenot phd office 353 meserve hall office hours m th 130 300 pm times dont work just dm slack set alternate time usually available slack just dm mfontenotnortheasternedu 2 teaching assistants iker acosta venegas dallon archibald nathan cheung aryan jain sevinch noori abhishek kumar eddy liu junxiang lin 3 course materials notes assignments httpsmarkfontenotnetteachingds430025s ds4300 assignment submissions grades gradescope q platform campuswire quick dms announcements slack 4 whats class end class understand efficiency related concepts including limitations rdbmss understand data replication distribution effects typical db usage scenarios understand use cases data models various nosql database systems including storing retrieving data data models include document based key value stores graph based access implement data engineering big data related aws services 5 course deliverables evaluation 6 assignments homeworks practicals usually tuesday nights 1159 unless stated 3 bonus submitting 48 hours early 3 submitting 48 hours early late submissions accepted life happens gets 1 free questions asked 48 hour extension dm dr fontenot slack original deadline requesting use extension 7 assignments submissions gradescope andor github unless directed submit pdfs unless instructed submitting pdf sure associate questions gradescope correct page pdf failure result grade 0 assignment regrade requests submitted 48 hours grades released gradescope exceptions 8 midterm monday march 17 mark calendars 9 final grade breakdown homeworks 5 30 practicals 2 20 midterm 20 semester project 30 10 reference materials primary resources books playlist add additional materials playlist webpage semester progresses oreilly playlist 11 tentative list topics thinking data storage retrieval data structures level far relational model nosql databases document databases mongo graph databases neo4j keyvalue databases maybe vector databases data distribution replication distributed sql dbs apache sparksparksql big data tools services aws 12 tools need install laptop docker desktop anaconda miniconda python youre welcome use distro youre responsible fixing doesnt work dependency conflicts database access tool like datagrip dbeaver vs code set python development info vscode python anaconda ability interact git github terminal gui app 13 topics review days shellcmd promptpowershell cli windows want unix terminal wsl2 zsh windows navigating file running commands like pip conda python command line args docker docker compose basics dockerfiles docker composeyaml files port mapping setting volumes mapping host guest os 14 python rusty havent ton python crash course net ninja yt oreilly python section class playlist python object oriented programming video course simon sez e matthes python crash course 3rd edition starch press related yt video playlist listed 15 expectations conduct respectfully dont distract classmates learning dont cheat work unless group assignment discussing problems encouraged formulate solutions syllabus details 16 lets gooo 17",
    "ds 4300 neo4j mark fontenot phd northeastern university material referenced graph algorithms practical examples apache spark neo4j needham hodler oreilly press 2019 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 2 neo4j query language plugins cypher neo4js graph query language created 2011 goal sql equivalent language graph databases provides visual way matching patterns relationships nodes connect othernodes apoc plugin awesome procedures cypher add library provides hundreds procedures functions graph data science plugin provides efficient implementations common graph algorithms like ones talked yesterday 3 neo4j docker compose 4 docker compose supports multi container management set declarative using yaml docker composeyaml file services volumes networks 1 command used start stop scale number services time provides consistent method producing identical environment works machine interaction command line 5 docker composeyaml services secrets neo4j container neo4j docker compose file use env image neo4jlatest ports files 74747474 76877687 environment neo4j authneo4jneo4j password neo4j apoc export file enabledtrue neo4j apoc import file enabledtrue neo4j apoc import file use neo4j configtrue neo4j pluginsapoc graph data science volumes neo4j dbdatadata neo4j dblogslogs neo4j dbimportvarlibneo4jimport neo4j dbpluginsplugins 6 env files env files stores collection environment variables good way environment variables different platforms separate envlocal env file envdev envprod neo4j passwordabc123 7 docker compose commands test docker cli properly installed run docker version major docker commands docker compose docker compose d docker compose docker compose start docker compose stop docker compose build docker compose build cache 8 localhost7474 9 neo4j browser localhost7474 login httpsneo4jcomdocsbrowser manualcurrentvisual tour 10 inserting data creating nodes create user alice birthplace paris create user bob birthplace london create user carol birthplace london create user dave birthplace london create user eve birthplace rome 11 adding edge variable names create user alice birthplace paris create user bob birthplace london match aliceuser namealice match bobuser bob create alice knows 2022 12 01 bob note relationships directed neo4j 12 matching users born london match usruser birthplace london return usrname usrbirthplace 13 download dataset import folder clone repo httpsgithubcompacktpublishinggraph data science neo4j chapter02data data repo unzip netflixzip file copy netflix titlescsv following folder docker compose file neo4j dbneo4j dbimport 14 importing data 15 basic data importing type following cypher editor neo4j browser load csv headers filenetflix titlescsv line createmovie id lineshow id title linetitle releaseyear linerelease year 16 loading csvs general syntax load csv headers filefile import foldercsv line fieldterminator stuffs line 17 importing directors time load csv headers filenetflix titlescsv line splitlinedirector directors list unwind directors list director create person trimdirector generates duplicate person nodes director direct 1 movie 18 importing directors merged match pperson delete p load csv headers filenetflix titlescsv line splitlinedirector directors list unwind directors list director merge person director 19 adding edges load csv headers filenetflix titlescsv line match mmovie id lineshow id m splitlinedirector directors list unwind directors list director match pperson director create p directed m 20 gut check lets check movie titled ray match mmovie title ray directed pperson return m p 21 22",
    "chapter 12 binary search trees binary search tree binary tree special property called bst property given follows nodes x y y belongs left subtree x key y key x y belongs right subtree x key y greater key x assume keys bst pairwise distinct node following attributes cid15 p left right pointers parent left child right child respectively cid15 key key stored node 1 example 7 4 12 2 6 9 19 3 5 8 11 15 20 2 traversal nodes bst traversal mean visiting nodes graph traversal strategies specicid12ed ordering objects visit current node left subtree right subtree assume left subtree comes right subtree strategies 1 inorder ordering left subtree current node right subtree 2 preorder ordering current node left subtree right subtree 3 postorder ordering left subtree right subtree current node 3 inorder traversal pseudocode recursive algorithm takes input pointer tree executed inorder traversal tree doing traversal prints key node visited inorder walk x nil 1 x return inorder walk 2 leftx 3 print keyx inorder walk 4 rightx write similar pseudocode preorder postorder 4 2 1 3 1 3 2 3 1 2 inorder preorder postorder 7 4 12 2 6 9 19 3 5 8 11 15 20 outcome inorder traversal bst postorder traversal preorder traversal 5 inorder traversal gives 2 3 4 5 6 7 8 9 11 12 15 19 20 preorder traversal gives 7 4 2 3 6 5 12 9 8 11 19 15 20 postorder traversal gives 3 2 5 6 4 8 11 9 15 20 19 12 7 inorder travel bst cid12nds keys nondecreasing order 6 operations bst 1 searching key assume key subtree key searched given input advantage bst property suppose node node key searched search key current node strictly smaller key searched strictly greater key searched case bst property keys th left subtree strictly key searched means need search left subtree examine right subtree case symmetry examine right subtree 7 algorithm k key searched x start node bst search x k 1 y x nil 2 y 6 3 keyy k return y 4 keyy k y righty 5 y lefty 6 return 8 example 7 search 8 4 11 2 6 9 13 nil running time search 9 2 maximum minimum cid12nd minimum identify leftmost node farthest node reach following left branches cid12nd maximum identify rightmost node farthest node reach following right branches bst minimum x nil 1 x return tree 2 y x nil 3 lefty 6 y lefty 4 return keyy bst maximum x nil 1 x return tree 2 y x nil 3 righty 6 y righty 4 return keyy 10 3 insertion suppose need insert node z k keyz using binary search cid12nd nil replacing z does break bst property 11 bst insert x z k nil 1 x return error 2 y x true 3 f 4 keyy k 5 z lefty 6 z righty nil 7 z break 8 g 9 keyy k lefty z 10 rightpy z 12 4 successor predecessor successor respectively predecessor key k search tree smallest respectively largest key belongs tree strictly greater respectively k idea cid12nding successor given node x cid15 x right child successor minimum right subtree x cid15 successor parent farthest node reached x following right branches backward 13 example 23 25 7 4 12 2 6 9 19 3 5 8 11 15 20 14 algorithm bst successor x nil 1 rightx 6 2 f y rightx nil 3 lefty 6 y lefty 4 return y g 5 6 f y x 7 rightpx x y px nil 8 px 6 return px 9 return successor g 15 predecessor similarly",
    "impossible distributed data store simultaneously provide following guarantees consistency read receives recent write error thrown availability request receives non error response guarantee response contains recent write partition tolerance continue operate despite arbitrary network issues 19 cap theorem database view consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 20 cap theorem database view consistency availability responds latest data request gets response able deal network issues consistency partition tolerance responds data distributed store latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 21 cap reality really saying limit number faults requests directed server insist serving request possibly consistent interpreted consistency availability tolerance failure 22 23",
    "drama dbmoviescountdocuments year 2010 awardswins gte 5 genres drama 28 mongosh project return names movies movies collection released 2010 won 5 awards genre drama dbmoviescountdocuments year 2010 awardswins gte 5 genres drama 1 id 0 1 return 0 dont return 29 pymongo 30 pymongo pymongo python library interfacing mongodb instances pymongo import mongoclient client mongoclient mongodbuser namepwlocalhost27017 31 getting database collection pymongo import mongoclient client mongoclient mongodbuser namepwlocalhost27017 db clientds4300 collection dbmycollection 32 inserting single document db clientds4300 collection dbmycollection post author mark text mongodb cool tags mongodb python post id collectioninsert onepostinserted id printpost id 33 count documents collection select count collection demodbcollectioncount documents 34 35"
  ],
  "config": {
    "chunk_size": 1000,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0076,
    "llm_response_time_sec": 15.7837,
    "memory_before_MB": 10.76,
    "memory_after_MB": 12.62
  }
}
{
  "question": "What is disk-based indexing and why is it important for database systems?",
  "llm_response": "Disk-based indexing is a method used in database systems to organize data efficiently, allowing for faster retrieval of specific records. It works by creating an additional structure (index file) that stores the location (or pointers) where data is stored on disk, rather than the actual data itself. The goal is to minimize the number of physical reads from the disk when searching or sorting data.\n\nIndexing is important for several reasons:\n\n1. **Improved Search Performance**: Indexes enable faster search operations by reducing the amount of data that needs to be scanned. Without indexes, databases would have to scan through each record one-by-one to find the desired information, which can be slow and inefficient, especially for large datasets.\n\n2. **Reduced I/O Operations**: Indexing reduces the number of disk reads required by a database, as it allows the database engine to skip over irrelevant data quickly. This is particularly important in modern systems where disk access speed is much slower than CPU or memory operations.\n\n3. **Sorting and Query Optimization**: Indexes can be used to sort data efficiently, making it easier for queries to retrieve specific records based on sorted columns. Additionally, indexes play a crucial role in query optimization, as they help the database engine determine the most efficient way to execute complex queries.\n\n4. **Support for Large Datasets**: As databases grow in size, efficient methods for organizing and accessing data become increasingly important. Indexing helps scale database systems to handle large amounts of data while maintaining reasonable search performance.",
  "context": [
    "sequence writes happens certain order reading writes appear order 24 25",
    "ds 4300 large scale information storage retrieval mark fontenot phd northeastern university hi mark fontenot phd office 353 meserve hall office hours m th 130 300 pm times dont work just dm slack set alternate time usually available slack just dm mfontenotnortheasternedu 2 teaching assistants iker acosta venegas dallon archibald nathan cheung aryan jain sevinch noori abhishek kumar eddy liu junxiang lin 3 course materials notes assignments httpsmarkfontenotnetteachingds430025s ds4300 assignment submissions grades gradescope q platform campuswire quick dms announcements slack 4 whats class end class understand efficiency related concepts including limitations rdbmss understand data replication distribution effects typical db usage scenarios understand use cases data models various nosql database systems including storing retrieving data data models include document based key value stores graph based access implement data engineering big data related aws services 5 course deliverables evaluation 6 assignments homeworks practicals usually tuesday nights 1159 unless stated 3 bonus submitting 48 hours early 3 submitting 48 hours early late submissions accepted life happens gets 1 free questions asked 48 hour extension dm dr fontenot slack original deadline requesting use extension 7 assignments submissions gradescope andor github unless directed submit pdfs unless instructed submitting pdf sure associate questions gradescope correct page pdf failure result grade 0 assignment regrade requests submitted 48 hours grades released gradescope exceptions 8 midterm monday march 17 mark calendars 9 final grade breakdown homeworks 5 30 practicals 2 20 midterm 20 semester project 30 10 reference materials primary resources books playlist add additional materials playlist webpage semester progresses oreilly playlist 11 tentative list topics thinking data storage retrieval data structures level far relational model nosql databases document databases mongo graph databases neo4j keyvalue databases maybe vector databases data distribution replication distributed sql dbs apache sparksparksql big data tools services aws 12 tools need install laptop docker desktop anaconda miniconda python youre welcome use distro youre responsible fixing doesnt work dependency conflicts database access tool like datagrip dbeaver vs code set python development info vscode python anaconda ability interact git github terminal gui app 13 topics review days shellcmd promptpowershell cli windows want unix terminal wsl2 zsh windows navigating file running commands like pip conda python command line args docker docker compose basics dockerfiles docker composeyaml files port mapping setting volumes mapping host guest os 14 python rusty havent ton python crash course net ninja yt oreilly python section class playlist python object oriented programming video course simon sez e matthes python crash course 3rd edition starch press related yt video playlist listed 15 expectations conduct respectfully dont distract classmates learning dont cheat work unless group assignment discussing problems encouraged formulate solutions syllabus details 16 lets gooo 17",
    "ds 4300 large scale information storage retrieval foundations mark fontenot phd northeastern university searching searching common operation performed database sql select statement arguably versatile complex baseline efficiency linear search start beginning list proceed element element youre looking element havent 2 searching record collection values attributes single entity instance row table collection set records entity type table trivially stored sequential order like list search key value attribute entity type 1 attribute 3 lists records record takes x bytes memory n records need nx bytes memory contiguously allocated list nx bytes allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses 4 contiguous vs linked 6 records contiguously allocated array extra storage memory address 6 records linked memory addresses linked list 5 pros cons arrays faster random access slow inserting end records insert 2nd record records 5 records moved make space linked lists faster inserting list slower random access insert 2nd record 6 observations arrays fast random access slow random insertions linked lists slow random access fast random insertions 7 binary search input array values sorted order target value output location index target located value indicating target def binary searcharr target left right 0 lenarr 1 left right left right c g m p r z target mid left right 2 arrmid target mid return mid target arrmid reset right mid 1 left right elif arrmid target left mid 1 c g m p r z target mid right mid 1 return 1 8 time complexity linear search best case target element 1 comparison worst case target array n comparisons worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog n time 2 complexity 9 database searching assume data stored disk column ids value searching specific id fast want search specific specialval option linear scan column store data disk sorted id specialval time data duplicated space inefficient 10 database searching assume data stored disk column ids value searching specific id fast want search specific need external data structure specialval support faster searching option linear scan column specialval linear scan store data disk sorted id specialval time data duplicated space inefficient 11 arsenal 1 array tuples specialval rownumber sorted specialval use binary search quickly locate particular specialval corresponding row table b insert table like inserting sorted array slow 2 linked list tuples specialval rownumber sorted specialval searching specialval slow linear scan required b inserting table theoretically quick add list 12 fast insert fast search binary search tree binary tree node left subtree parent node right subtree greater parent image httpscoursesgraingerillinoiseducs225sp2019notesbst 13 board 14",
    "ds 4300 neo4j mark fontenot phd northeastern university material referenced graph algorithms practical examples apache spark neo4j needham hodler oreilly press 2019 neo4j graph database supports transactional analytical processing graph based data relatively new class sql dbs considered schema optional imposed supports various types indexing acid compliant supports distributed computing similar microsoft cosmodb amazon neptune 2 neo4j query language plugins cypher neo4js graph query language created 2011 goal sql equivalent language graph databases provides visual way matching patterns relationships nodes connect othernodes apoc plugin awesome procedures cypher add library provides hundreds procedures functions graph data science plugin provides efficient implementations common graph algorithms like ones talked yesterday 3 neo4j docker compose 4 docker compose supports multi container management set declarative using yaml docker composeyaml file services volumes networks 1 command used start stop scale number services time provides consistent method producing identical environment works machine interaction command line 5 docker composeyaml services secrets neo4j container neo4j docker compose file use env image neo4jlatest ports files 74747474 76877687 environment neo4j authneo4jneo4j password neo4j apoc export file enabledtrue neo4j apoc import file enabledtrue neo4j apoc import file use neo4j configtrue neo4j pluginsapoc graph data science volumes neo4j dbdatadata neo4j dblogslogs neo4j dbimportvarlibneo4jimport neo4j dbpluginsplugins 6 env files env files stores collection environment variables good way environment variables different platforms separate envlocal env file envdev envprod neo4j passwordabc123 7 docker compose commands test docker cli properly installed run docker version major docker commands docker compose docker compose d docker compose docker compose start docker compose stop docker compose build docker compose build cache 8 localhost7474 9 neo4j browser localhost7474 login httpsneo4jcomdocsbrowser manualcurrentvisual tour 10 inserting data creating nodes create user alice birthplace paris create user bob birthplace london create user carol birthplace london create user dave birthplace london create user eve birthplace rome 11 adding edge variable names create user alice birthplace paris create user bob birthplace london match aliceuser namealice match bobuser bob create alice knows 2022 12 01 bob note relationships directed neo4j 12 matching users born london match usruser birthplace london return usrname usrbirthplace 13 download dataset import folder clone repo httpsgithubcompacktpublishinggraph data science neo4j chapter02data data repo unzip netflixzip file copy netflix titlescsv following folder docker compose file neo4j dbneo4j dbimport 14 importing data 15 basic data importing type following cypher editor neo4j browser load csv headers filenetflix titlescsv line createmovie id lineshow id title linetitle releaseyear linerelease year 16 loading csvs general syntax load csv headers filefile import foldercsv line fieldterminator stuffs line 17 importing directors time load csv headers filenetflix titlescsv line splitlinedirector directors list unwind directors list director create person trimdirector generates duplicate person nodes director direct 1 movie 18 importing directors merged match pperson delete p load csv headers filenetflix titlescsv line splitlinedirector directors list unwind directors list director merge person director 19 adding edges load csv headers filenetflix titlescsv line match mmovie id lineshow id m splitlinedirector directors list unwind directors list director match pperson director create p directed m 20 gut check lets check movie titled ray match mmovie title ray directed pperson return m p 21 22",
    "ds 4300 nosql kv dbs mark fontenot phd northeastern university material used permission dr rachlin thanks distributed dbs acid pessimistic concurrency acid transactions focuses data safety considered pessimistic concurrency model assumes transaction protect transactions iow assumes wrong conflicts prevented locking resources transaction complete read write locks write lock analogy borrowing book library httpswwwfreecodecamporgnewshow databases guarantee isolation deeper dive 2 optimistic concurrency transactions obtain locks data read write optimistic assumes conflicts unlikely occur conflict ok add update timestamp version number columns table read changing check end transaction transaction caused modified 3 optimistic concurrency low conflict systems backups analytical dbs read heavy systems conflicts arise handled rolling running transaction notices conflict optimistic concurrency works allows higher concurrency high conflict systems rolling rerunning transactions encounter conflict efficient locking scheme pessimistic model preferable 4 nosql nosql used 1998 carlo strozzi relational database did use sql common modern meaning sql thought non relational dbs idea originally developed response processing unstructured web based data httpswwwdataversityneta brief history non relational databases 5 cap theorem review 2 3 following consistency user db identical view data given instant availability event failure database remains operational partition tolerance database maintain operations event networks failing segments distributed note definition consistency cap different acid reference httpsalperenbayramoglucompostsunderstanding cap theorem 6 cap theorem review consistency availability responds latest data request gets response able deal network partitions consistency partition tolerance responds data distrib latest data request dropped availability partition tolerance sends responds based distributed store absolute latest data reference httpsalperenbayramoglucompostsunderstanding cap theorem 7 acid alternative distrib systems base basically available guarantees availability data cap response failureunreliable data inconsistent changing state appears work time 8 acid alternative distrib systems base soft state state change time wo input changes result eventual consistency data stores dont write consistent replicas dont mutually consistent 9 acid alternative distrib systems base eventual consistency eventually consistent writes eventually stop nodesreplicas updated 10 categories nosql dbs review 11 key value databases 12 key value stores key value key value stores designed simplicity data model extremely simple comparatively tables rdbms complex lends simple crud ops api creation 13 key value stores key value key value stores designed speed usually deployed memory db retrieving value given key typically o1 op bc hash tables similar data structs used hood concept complex queries joins slow things 14 key value stores key value key value stores designed scalability horizontal scaling simple add nodes typically concerned eventual consistency meaning distributed environment guarantee nodes eventually converge value 15 kv ds use cases edaexperimentation results store store intermediate results data preprocessing eda store experiment testing ab results wo prod db feature store store frequently accessed feature low latency retrieval model training prediction model monitoring store key metrics performance model example real time inferencing 16 kv swe use cases storing session information current session stored single post retrieved single fast user profiles preferences user info obtained single operation language tz product ui preferences shopping cart data cart data tied user needs available browsers machines sessions caching layer disk based database 17 redis db redis remote directory server open source memory database called data structure store primarily kv store used models graph spatial text search vector time series db enginescom ranking kv stores 18 redis considered memory database supports durability data essentially saving snapshots disk specific intervals b append file journal changes used roll forward failure originally developed 2009 c fast 100000 set ops second rich",
    "general trade offs exist consistency availability performance indexing strategies significantly impact query performance nosql databases great unstructured data sacrifice strong consistency graph databases optimized relationships large scale storage retrieval foundations foundations large scale storage retrieval introduction information storage information retrieval ir process storing organizing retrieving data efficiently ir systems range search engines google databases storing medical records key challenges scalability handling petabytes data efficiency fast retrieval times google milliseconds consistency availability ensuring fault tolerance reliability searching strategies linear search simple inefficient time complexity binary search works sorted data olog n complexity indexing key making search efficient uses external data structures like b trees hash indexes indexing techniques hash indexing best unique lookups o1 average case b trees b trees used databases optimized disk access inverted index used search engines maps words documents record collection values attribues single entity instance row table collection set records entity type table trvially stored sequuential order like list search key value attribute entity type 1 attribute nx bytes memory record takes x bytes memory n records need contiguously allocated list nx byte allocated single chunk memory linked list record needs x bytes additional space 1 2 memory addresses individual records linked type chain using memory addresses arrays faster random access inserting end slow linked lists faster inserting list random access slow linear search best case 1 worst case binary search best case 1 worst case log2n read code explain binary search isdoes binary search tree binary tree node left subtree parent node right parent avl tree approx balanced binary search tree maintains balance faster avl property hlst hrst 1 self balancing inserting imbalance ll lr rl rr trees b trees indexing b trees used database indexing filesystems ntfs postgresql indexes keeps tree height small reducing disk reads b trees vs b trees b trees store keys values internal leaf nodes b trees store values leaf nodes making range queries efficient bst properties left subtree values root right subtree values search time complexity olog n balanced unbalanced avl trees self balancing bst ensures olog n search time rotations used rebalancing ll rotation single right rotation rr rotation single left rotation lr rotation left right rotation rl rotation right left rotation sql vs sql sql structured query langage relational easy querying relationships data multiple datas acid compliant atomicity consistency isolation durability good storing querying unstructured data format unknown difficult scale horizontally nosql document keyvalue graph wide column stores flexible simpler set shard data different data stores allowing distributed databases making horizontal scaling easier large data stored designed distributed purposes optimistic concurrency assumes conflicts unlikely occur add updated timestamp version number columns table modified independently transactions relational databases vs nosql acid vs base acid ensures strong consistency atomicity transactions consistency data remains valid isolation transactions interfere durability committed stays committed base prioritizes availability consistency basically available soft state eventually consistent sql vs nosql feature sql relational nosql non relational schema fixed structured flexible dynamic scalability vertical scale horizontal scale consistency strong acid compliance eventual consistency examples mysql postgresql mongodb cassandra neo4j nosql cap theorem consistency nodes data simultaneously availability request gets response stale partition tolerance functions despite network failures nosql categories type example use case key value redis caching real time stores dynamodb analytics document mongodb json like flexible data stores couchdb models column stores apache time series analytics cassandra graph neo4j relationship heavy data databases graph data models neo4j graph theory basics nodes entities users products edges relationships nodes traversal algorithms bfs dfs dijkstras shortest path neo4j cypher neo4j acid compliant graph database cypher query examples match friend b return b data replication distributed systems improves fault tolerance node crashes serve data enables load balancing distribute requests multiple servers replication strategies master slave replication node handles writes replicate reads multi master replication multiple nodes accept writes requires conflict resolution eventual consistency updates propagate time used nosql systems like dynamodb",
    "ds 4300 redis python mark fontenot phd northeastern university redis py redis py standard client python maintained redis company github repo redisredis py 4300 conda environment pip install redis 2 connecting server import redis redis client redisredishostlocalhost port6379 db2 decode responsestrue docker deployment host localhost 127001 port port mapping given created container probably default 6379 db database 0 15 want connect decode responses data comes server bytes setting true converter decodes strings 3 redis command list list use filter command particular data structure youre targeting list hash set redispy documentation slides meant exhaustive list commands highlights check documentation complete list 4 string commands r represents redis client object rsetclickcountabc 0 val rgetclickcountabc rincrclickcountabc ret val rgetclickcountabc printfclick count ret val 5 string commands 2 r represents redis client object redis clientmsetkey1 val1 key2 val2 key3 val3 printredis clientmgetkey1 key2 key3 returns list val1 val2 val3 6 string commands 3 set mset setex msetnx setnx mget getex getdel incr decr incrby decrby strlen append 7 list commands 1 create list key names values mark sam nick redis clientrpushnames mark sam nick prints mark sam nick printredis clientlrangenames 0 1 8 list commands 2 lpush lpop lset lrem rpush rpop lrange llen lpos commands include moving elements lists popping multiple lists time 9 hash commands 1 redis clienthsetuser session123 mappingfirst sam uelle company redis age 30 prints sam surname uelle company redis age 30 printredis clienthgetalluser session123 10 hash commands 2 hset hget hgetall hkeys hdel hexists hlen hstrlen 11 redis pipelines helps avoid multiple related calls server network overhead r redisredisdecode responsestrue pipe rpipeline range5 pipesetfseati fi set 5 result pipeexecute printset 5 result true true true true true pipe rpipeline chain pipeline commands 3 result pipegetseat0getseat3getseat4execute printget 3 result 0 3 4 12 redis context 13 redis ml simplified example source httpswwwfeatureformcompostfeature stores explained common architectures 14 redis dsml source httpsmadewithmlcomcoursesmlopsfeature store 15",
    "assumes conflicts occur uses locks optimistic concurrency locks assumes conflicts rare uses timestamps version numbers good read heavy systems efficient high conflict systems base alternative acid distributed systems basically available works time soft state state change input eventual consistency eventually reach consistency 8 key value databases design principles simplicity extremely simple data model compared rdbms speed memory o1 retrieval operations scalability easy horizontal scaling eventual consistency use cases data science experiment results storage feature storage model monitoring software engineering session information user profiles shopping carts caching 9 redis key value database open source memory database high performance 100000 set opssecond supports data durability snapshots append journals simple lookup key secondary indexes data types strings basic textbinary data lists linked lists queuesstacks sets unique unordered string collections hashes field value collections sorted sets sets scores ordering specialized types geospatial data json common operations basic crud set exists del atomic counters incr incrby decr decrby list operations lpush rpush lpop rpop llen lrange set operations sadd scard sismember sinter sdiff hash operations hset hget hgetall",
    "database called data structure store primarily kv store used models graph spatial text search vector time series db enginescom ranking kv stores 18 redis considered memory database supports durability data essentially saving snapshots disk specific intervals b append file journal changes used roll forward failure originally developed 2009 c fast 100000 set ops second rich collection commands does handle complex data secondary indexes supports lookup key 19 redis data types keys usually strings binary sequence values strings lists linked lists sets unique unsorted string elements sorted sets hashes string string geospatial data 20 setting redis docker docker desktop search redis pullrun latest image optional settings add 6379 ports expose port connect normally expose redis port security reasons did prod environment major security hole notice didnt set password 21 connecting datagrip file new data source redis data source make sure port 6379 test connection 22 redis database interaction redis provides 16 databases default numbered 0 15 associated direct interaction redis set commands related setting getting kv pairs variations language libraries available 23 foundation data type string sequence bytes text serialized objects bin arrays simplest data type maps string string use cases caching frequently accessed htmlcssjs fragments config settings user settings info token management counting web pageapp screen views rate limiting 24 initial basic commands set pathtoresource 0 set user1 john doe pathtoresource exists user1 del user1 keys user select 5 select different database 25 basic commands set somevalue 0 incr somevalue increment 1 incrby somevalue 10 increment 10 decr somevalue decrement 1 decrby somevalue 5 decrement 5 incr parses value int increments adds value setnx key value sets value key key does exist 26 hash type value kv entry collection field value pairs use cases used represent basic objectsstructures number fieldvalue pairs hash 232 1 practical limit available resources memory session information management userevent tracking include ttl active session tracking sessions hash key 27 hash commands hset bike1 model demios brand ergonom price 1971 hget bike1 model hget bike1 price hgetall bike1 hmget bike1 model price weight returned hincrby bike1 price 100 28 list type value kv pair linked lists string values use cases implementation stacks queues queue management message passing queues producerconsumer model logging systems easy chronological order build social media streamsfeeds message history chat application batch processing queueing set tasks executed sequentially later time 29 linked lists crash course 10 nil sequential data structure linked nodes instead contiguously allocated memory node points element list points nilnull o1 insert new value insert new value end 30 list commands queue queue like ops lpush bikesrepairs bike1 lpush bikesrepairs bike2 rpop bikesrepairs rpop bilesrepairs 31 list commands stack stack like ops lpush bikesrepairs bike1 lpush bikesrepairs bike2 lpop bikesrepairs lpop bilesrepairs 32 list commands lpush mylist lpush mylist list ops lpush mylist llen mylist lrange key start stop lrange mylist 0 3 lrange mylist 0 0 lrange mylist 2 1 33 json type support json standard uses jsonpath syntax parsingnavigating json document internally stored binary tree structure fast access sub elements 34 set type unordered collection unique strings members use cases track unique items ip addresses visiting site page screen primitive relation set students ds4300 access control lists users permission structures social network friends lists andor group membership supports set operations 35 set commands sadd ds4300 mark sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam sismember ds4300 mark sismember ds4300 nick scard ds4300 36 sadd ds4300 mark set commands sadd ds4300 sam sadd cs3200 nick sadd cs3200 sam scard ds4300 sinter ds4300 cs3200 sdiff ds4300 cs3200 srem ds4300 mark srandmember ds4300 37 38",
    "chapter 12 binary search trees binary search tree binary tree special property called bst property given follows nodes x y y belongs left subtree x key y key x y belongs right subtree x key y greater key x assume keys bst pairwise distinct node following attributes cid15 p left right pointers parent left child right child respectively cid15 key key stored node 1 example 7 4 12 2 6 9 19 3 5 8 11 15 20 2 traversal nodes bst traversal mean visiting nodes graph traversal strategies specicid12ed ordering objects visit current node left subtree right subtree assume left subtree comes right subtree strategies 1 inorder ordering left subtree current node right subtree 2 preorder ordering current node left subtree right subtree 3 postorder ordering left subtree right subtree current node 3 inorder traversal pseudocode recursive algorithm takes input pointer tree executed inorder traversal tree doing traversal prints key node visited inorder walk x nil 1 x return inorder walk 2 leftx 3 print keyx inorder walk 4 rightx write similar pseudocode preorder postorder 4 2 1 3 1 3 2 3 1 2 inorder preorder postorder 7 4 12 2 6 9 19 3 5 8 11 15 20 outcome inorder traversal bst postorder traversal preorder traversal 5 inorder traversal gives 2 3 4 5 6 7 8 9 11 12 15 19 20 preorder traversal gives 7 4 2 3 6 5 12 9 8 11 19 15 20 postorder traversal gives 3 2 5 6 4 8 11 9 15 20 19 12 7 inorder travel bst cid12nds keys nondecreasing order 6 operations bst 1 searching key assume key subtree key searched given input advantage bst property suppose node node key searched search key current node strictly smaller key searched strictly greater key searched case bst property keys th left subtree strictly key searched means need search left subtree examine right subtree case symmetry examine right subtree 7 algorithm k key searched x start node bst search x k 1 y x nil 2 y 6 3 keyy k return y 4 keyy k y righty 5 y lefty 6 return 8 example 7 search 8 4 11 2 6 9 13 nil running time search 9 2 maximum minimum cid12nd minimum identify leftmost node farthest node reach following left branches cid12nd maximum identify rightmost node farthest node reach following right branches bst minimum x nil 1 x return tree 2 y x nil 3 lefty 6 y lefty 4 return keyy bst maximum x nil 1 x return tree 2 y x nil 3 righty 6 y righty 4 return keyy 10 3 insertion suppose need insert node z k keyz using binary search cid12nd nil replacing z does break bst property 11 bst insert x z k nil 1 x return error 2 y x true 3 f 4 keyy k 5 z lefty 6 z righty nil 7 z break 8 g 9 keyy k lefty z 10 rightpy z 12 4 successor predecessor successor respectively predecessor key k search tree smallest respectively largest key belongs tree strictly greater respectively k idea cid12nding successor given node x cid15 x right child successor minimum right subtree x cid15 successor parent farthest node reached x following right branches backward 13 example 23 25 7 4 12 2 6 9 19 3 5 8 11 15 20 14 algorithm bst successor x nil 1 rightx 6 2 f y rightx nil 3 lefty 6 y lefty 4 return y g 5 6 f y x 7 rightpx x y px nil 8 px 6 return px 9 return successor g 15 predecessor similarly"
  ],
  "config": {
    "chunk_size": 1000,
    "vector_db": "redis",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0233,
    "llm_response_time_sec": 21.5611,
    "memory_before_MB": 12.25,
    "memory_after_MB": 13.84
  }
}
{
  "question": "When are linked lists faster than contiguously-allocated lists?",
  "llm_response": "Linked lists are faster when dealing with dynamic scenarios where the size of the list is frequently changing, as inserting or deleting elements in the middle of a contiguous list requires rearranging the entire array. In contrast, linked lists can easily add or remove nodes without affecting the rest of the list. However, when the list size is constant and access to specific elements is frequent, contiguously-allocated lists are faster due to their constant time (O(1)) complexity for accessing an element at a given index.",
  "context": [
    "want upper bound ey n n cid21 2 n 1 0 1 ey 2emaxfy y g n icid01 ncid0i n x i1 emaxfy y g cid20 ey y icid01 ncid0i icid01 ncid0i cid20 ey ey icid01 ncid0i collecting terms ncid01 4 ey cid20 ey n n x i1 24 analysis 1 n3 claim n cid21 1 ey cid20 n 4cid16 3 cid17 prove induction n 0 base case ey 2 1 1 induction step ncid01 4 ey cid20 ey n n x",
    "github unless directed submit pdfs unless instructed submitting pdf sure associate questions gradescope correct page pdf failure result grade 0 assignment regrade requests submitted 48 hours grades released gradescope exceptions 8 midterm monday march 17 mark calendars 9 final grade breakdown homeworks 5 30 practicals 2 20 midterm 20 semester project 30 10 reference materials primary resources",
    "13 nil running time search 9 2 maximum minimum cid12nd minimum identify leftmost node farthest node reach following left branches cid12nd maximum identify rightmost node farthest node reach following right branches bst minimum x nil 1 x return tree 2 y x nil 3 lefty 6 y lefty 4 return keyy bst maximum x nil 1 x return tree 2 y x nil 3",
    "ncid01 4 ey cid20 ey n n x i1 using fact ncid01 3 n 3 x cid16 3 cid17 cid16 4 cid17 i0 4 1 n 3 ey cid20 cid1 cid1 n cid16 cid17 n 4 4 1 n 3 ey cid20 cid1 n cid16 cid17 4 3 25 jensens inequality function f convex x y x y cid21 0 cid20 cid21 cid20 1 fcid21x 1 cid0 cid21y cid20 cid21fx 1 cid0 cid21fy jensens inequality states random variables x convex",
    "typically concerned eventual consistency meaning distributed environment guarantee nodes eventually converge value 15 kv ds use cases edaexperimentation results store store intermediate results data preprocessing eda store experiment testing ab results wo prod db feature store store frequently accessed feature low latency retrieval model training prediction model monitoring store key metrics performance model example real time inferencing 16 kv swe use cases storing session information current session",
    "complex lends simple crud ops api creation 13 key value stores key value key value stores designed speed usually deployed memory db retrieving value given key typically o1 op bc hash tables similar data structs used hood concept complex queries joins slow things 14 key value stores key value key value stores designed scalability horizontal scaling simple add nodes typically concerned eventual consistency meaning distributed",
    "assignments httpsmarkfontenotnetteachingds430025s ds4300 assignment submissions grades gradescope q platform campuswire quick dms announcements slack 4 whats class end class understand efficiency related concepts including limitations rdbmss understand data replication distribution effects typical db usage scenarios understand use cases data models various nosql database systems including storing retrieving data data models include document based key value stores graph based access implement data engineering big data related aws services 5 course",
    "worst case linear search time complexity binary search best case target mid 1 comparison inside loop worst case target array log n comparisons 2 worst case binary search olog n time 2 complexity 9 database searching assume data stored disk column ids value searching specific id fast want search specific specialval option linear scan column",
    "left right left right c g m p r z target mid left right 2 arrmid target mid return mid target arrmid reset right mid 1 left right elif arrmid target left mid 1 c g m p r z target mid right mid 1 return 1 8 time complexity linear search best case target element 1 comparison worst case target array n comparisons worst case linear search time",
    "random inserted tree keys inserted keys greater x right subtree x keys smaller x left subtree height tree constructed plus larger height left subtree height right subtree 23 random variables n number keys x height tree n keys n x y 2 n n want upper bound ey n n cid21"
  ],
  "config": {
    "chunk_size": 100,
    "vector_db": "chroma",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0165,
    "llm_response_time_sec": 8.2029,
    "memory_before_MB": 18.45,
    "memory_after_MB": 24.36
  }
}
{
  "question": "What is the difference between a list where memory is contiguously allocated and a list where linked structures are used?\n",
  "llm_response": "In a list where memory is contiguously allocated, all elements of the list are stored in a single block of memory. This type of data structure is often more efficient for operations like accessing elements at specific indexes or inserting/deleting elements at specific positions because it allows for constant time complexity for these operations. However, this approach may not be as efficient when dealing with large lists, as reallocating the memory block can be costly.\n\n   On the other hand, in a list where linked structures are used, each element is stored individually and linked to the next one. This type of data structure allows for dynamic resizing without having to constantly reallocate memory, making it more efficient when dealing with large lists. However, accessing elements at specific indexes or inserting/deleting elements at specific positions may have a higher time complexity due to the need to traverse through the linked structures.\n\n   In Redis, which is discussed in the provided context, lists can be implemented either way depending on the use case and the characteristics of the data being stored. For example, when using the LIST commands like LPUSH or LRANGE in Redis, it uses an implementation with contiguous memory allocation for better performance when dealing with large lists. But internally, Redis still maintains a doubly-linked list (i.e., linked structures) to support efficient traversal and manipulation of the elements within the list.",
  "context": [
    "ds 4300 redis python mark fontenot phd northeastern university redis py redis py standard client python maintained redis company github repo redisredis py 4300 conda environment pip install redis 2 connecting server import redis redis client redisredishostlocalhost port6379 db2 decode responsestrue docker deployment host localhost 127001 port port mapping given created container probably default 6379 db database 0 15 want connect decode responses data comes server bytes setting true",
    "fast 100000 set ops second rich collection commands does handle complex data secondary indexes supports lookup key 19 redis data types keys usually strings binary sequence values strings lists linked lists sets unique unsorted string elements sorted sets hashes string string geospatial data 20 setting redis docker docker desktop search redis pullrun latest image optional settings add 6379 ports expose port connect",
    "data comes server bytes setting true converter decodes strings 3 redis command list list use filter command particular data structure youre targeting list hash set redispy documentation slides meant exhaustive list commands highlights check documentation complete list 4 string commands r represents redis client object rsetclickcountabc 0 val rgetclickcountabc rincrclickcountabc ret val rgetclickcountabc printfclick count ret val 5 string commands 2 r represents redis client object redis clientmsetkey1",
    "rpipeline chain pipeline commands 3 result pipegetseat0getseat3getseat4execute printget 3 result 0 3 4 12 redis context 13 redis ml simplified example source httpswwwfeatureformcompostfeature stores explained common architectures 14 redis dsml source httpsmadewithmlcomcoursesmlopsfeature store 15",
    "sequence writes happens certain order reading writes appear order 24 25",
    "commands 2 r represents redis client object redis clientmsetkey1 val1 key2 val2 key3 val3 printredis clientmgetkey1 key2 key3 returns list val1 val2 val3 6 string commands 3 set mset setex msetnx setnx mget getex getdel incr decr incrby decrby strlen append 7 list commands 1 create list key names values mark sam nick redis clientrpushnames mark sam nick prints mark sam nick printredis clientlrangenames 0 1 8 list commands 2 lpush lpop lset lrem rpush rpop lrange llen lpos commands include moving elements lists popping multiple",
    "commands set pathtoresource 0 set user1 john doe pathtoresource exists user1 del user1 keys user select 5 select different database 25 basic commands set somevalue 0 incr somevalue increment 1 incrby somevalue 10 increment 10 decr somevalue decrement 1 decrby somevalue 5 decrement 5 incr parses value int increments adds value setnx key value sets value key key does exist 26 hash type value kv entry collection field value pairs use",
    "commands include moving elements lists popping multiple lists time 9 hash commands 1 redis clienthsetuser session123 mappingfirst sam uelle company redis age 30 prints sam surname uelle company redis age 30 printredis clienthgetalluser session123 10 hash commands 2 hset hget hgetall hkeys hdel hexists hlen hstrlen 11 redis pipelines helps avoid multiple related calls server network overhead r redisredisdecode responsestrue pipe rpipeline range5 pipesetfseati fi set 5 result pipeexecute printset 5 result true true true true true pipe rpipeline chain pipeline commands 3 result pipegetseat0getseat3getseat4execute printget 3 result 0 3",
    "13 nil running time search 9 2 maximum minimum cid12nd minimum identify leftmost node farthest node reach following left branches cid12nd maximum identify rightmost node farthest node reach following right branches bst minimum x nil 1 x return tree 2 y x nil 3 lefty 6 y lefty 4 return keyy bst maximum x nil 1 x return tree 2 y x nil 3",
    "rownumber sorted specialval searching specialval slow linear scan required b inserting table theoretically quick add list 12 fast insert fast search binary search tree binary tree node left subtree parent node right subtree greater parent image httpscoursesgraingerillinoiseducs225sp2019notesbst 13 board 14"
  ],
  "config": {
    "chunk_size": 100,
    "vector_db": "chroma",
    "llm": "mistral",
    "overlap": 0,
    "cleaning": true
  },
  "metrics": {
    "retrieval_time_sec": 0.0102,
    "llm_response_time_sec": 15.5946,
    "memory_before_MB": 17.38,
    "memory_after_MB": 22.08
  }
}
